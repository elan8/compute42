CST dump for: C:\Users\jeroe\AppData\Local\com.juliajunction.dev\julia\julia-1.12.1\share\julia\base\error.jl
================================================================================

source_file [0:0 - 323:0] # This file is a part of Julia. License is MIT: https://juli...
  line_comment [0:0 - 0:77] # This file is a part of Julia. License is MIT: https://juli...
  line_comment [2:0 - 2:51] # pseudo-definitions to show how everything behaves
  line_comment [3:0 - 3:1] #
  line_comment [4:0 - 4:70] # throw(label, val) = # throw a value to a dynamically enclo...
  line_comment [5:0 - 5:1] #
  line_comment [6:0 - 6:23] # function rethrow(val)
  line_comment [7:0 - 7:36] #     global current_exception = val
  line_comment [8:0 - 8:49] #     throw(current_handler(), current_exception)
  line_comment [9:0 - 9:5] # end
  line_comment [10:0 - 10:1] #
  line_comment [11:0 - 11:40] # rethrow() = rethrow(current_exception)
  line_comment [12:0 - 12:1] #
  line_comment [13:0 - 13:21] # function throw(val)
  line_comment [14:0 - 14:42] #     global catch_backtrace = backtrace()
  line_comment [15:0 - 15:18] #     rethrow(val)
  line_comment [16:0 - 16:5] # end
  string_literal [18:0 - 24:3] """
    throw(e)

Throw an object as an exception.

See also...
    """ [18:0 - 18:3] """
    content [18:3 - 24:0] 
    throw(e)

Throw an object as an exception.

See also: [...
  identifier [25:0 - 25:5] throw
  line_comment [27:0 - 27:33] ## native julia error handling ##
  line_comment [29:0 - 29:110] # This is `Experimental.@max_methods 2 function error end`, ...
  line_comment [30:0 - 30:90] # NOTE It is important to always be able to infer the return...
  line_comment [31:0 - 31:91] # but there's a hitch when a package globally sets `@max_met...
  line_comment [32:0 - 32:53] # for `error(::Any)` to fail (JuliaLang/julia#54029).
  line_comment [33:0 - 33:94] # This definition site `@max_methods 2` setting overrides an...
  line_comment [34:0 - 34:91] # on package side, guaranteeing that return type inference o...
  function_definition [35:0 - 35:18] function error end
    function [35:0 - 35:8] function
    signature [35:9 - 35:14] error
      identifier [35:9 - 35:14] error
    end [35:15 - 35:18] end
  assignment [36:0 - 36:41] typeof(error).name.max_methods = UInt8(2)
    field_expression [36:0 - 36:30] typeof(error).name.max_methods
      field_expression [36:0 - 36:18] typeof(error).name
        call_expression [36:0 - 36:13] typeof(error)
          identifier [36:0 - 36:6] typeof
          argument_list [36:6 - 36:13] (error)
            ( [36:6 - 36:7] (
            identifier [36:7 - 36:12] error
            ) [36:12 - 36:13] )
        . [36:13 - 36:14] .
        identifier [36:14 - 36:18] name
      . [36:18 - 36:19] .
      identifier [36:19 - 36:30] max_methods
    operator [36:31 - 36:32] =
    call_expression [36:33 - 36:41] UInt8(2)
      identifier [36:33 - 36:38] UInt8
      argument_list [36:38 - 36:41] (2)
        ( [36:38 - 36:39] (
        integer_literal [36:39 - 36:40] 2
        ) [36:40 - 36:41] )
  string_literal [38:0 - 42:3] """
    error(message::AbstractString)

Raise an `ErrorExcep...
    """ [38:0 - 38:3] """
    content [38:3 - 42:0] 
    error(message::AbstractString)

Raise an `ErrorExceptio...
  assignment [43:0 - 43:51] error(s::AbstractString) = throw(ErrorException(s))
    call_expression [43:0 - 43:24] error(s::AbstractString)
      identifier [43:0 - 43:5] error
      argument_list [43:5 - 43:24] (s::AbstractString)
        ( [43:5 - 43:6] (
        typed_expression [43:6 - 43:23] s::AbstractString
          identifier [43:6 - 43:7] s
          :: [43:7 - 43:9] ::
          identifier [43:9 - 43:23] AbstractString
        ) [43:23 - 43:24] )
    operator [43:25 - 43:26] =
    call_expression [43:27 - 43:51] throw(ErrorException(s))
      identifier [43:27 - 43:32] throw
      argument_list [43:32 - 43:51] (ErrorException(s))
        ( [43:32 - 43:33] (
        call_expression [43:33 - 43:50] ErrorException(s)
          identifier [43:33 - 43:47] ErrorException
          argument_list [43:47 - 43:50] (s)
            ( [43:47 - 43:48] (
            identifier [43:48 - 43:49] s
            ) [43:49 - 43:50] )
        ) [43:50 - 43:51] )
  assignment [44:0 - 44:35] error() = throw(ErrorException(""))
    call_expression [44:0 - 44:7] error()
      identifier [44:0 - 44:5] error
      argument_list [44:5 - 44:7] ()
        ( [44:5 - 44:6] (
        ) [44:6 - 44:7] )
    operator [44:8 - 44:9] =
    call_expression [44:10 - 44:35] throw(ErrorException(""))
      identifier [44:10 - 44:15] throw
      argument_list [44:15 - 44:35] (ErrorException(""))
        ( [44:15 - 44:16] (
        call_expression [44:16 - 44:34] ErrorException("")
          identifier [44:16 - 44:30] ErrorException
          argument_list [44:30 - 44:34] ("")
            ( [44:30 - 44:31] (
            string_literal [44:31 - 44:33] ""
              " [44:31 - 44:32] "
            ) [44:33 - 44:34] )
        ) [44:34 - 44:35] )
  string_literal [46:0 - 50:3] """
    error(msg...)

Raise an `ErrorException` with a mess...
    """ [46:0 - 46:3] """
    content [46:3 - 50:0] 
    error(msg...)

Raise an `ErrorException` with a message...
  function_definition [51:0 - 54:3] function error(s::Vararg{Any,N}) where {N}
    @noinline
   ...
    function [51:0 - 51:8] function
    signature [51:9 - 51:42] error(s::Vararg{Any,N}) where {N}
      where_expression [51:9 - 51:42] error(s::Vararg{Any,N}) where {N}
        call_expression [51:9 - 51:32] error(s::Vararg{Any,N})
          identifier [51:9 - 51:14] error
          argument_list [51:14 - 51:32] (s::Vararg{Any,N})
            ( [51:14 - 51:15] (
            typed_expression [51:15 - 51:31] s::Vararg{Any,N}
              identifier [51:15 - 51:16] s
              :: [51:16 - 51:18] ::
              parametrized_type_expression [51:18 - 51:31] Vararg{Any,N}
                identifier [51:18 - 51:24] Vararg
                curly_expression [51:24 - 51:31] {Any,N}
                  { [51:24 - 51:25] {
                  identifier [51:25 - 51:28] Any
                  , [51:28 - 51:29] ,
                  identifier [51:29 - 51:30] N
                  } [51:30 - 51:31] }
            ) [51:31 - 51:32] )
        where [51:33 - 51:38] where
        curly_expression [51:39 - 51:42] {N}
          { [51:39 - 51:40] {
          identifier [51:40 - 51:41] N
          } [51:41 - 51:42] }
    macrocall_expression [52:4 - 52:13] @noinline
      macro_identifier [52:4 - 52:13] @noinline
        @ [52:4 - 52:5] @
        identifier [52:5 - 52:13] noinline
    call_expression [53:4 - 53:49] throw(ErrorException(Main.Base.string(s...)))
      identifier [53:4 - 53:9] throw
      argument_list [53:9 - 53:49] (ErrorException(Main.Base.string(s...)))
        ( [53:9 - 53:10] (
        call_expression [53:10 - 53:48] ErrorException(Main.Base.string(s...))
          identifier [53:10 - 53:24] ErrorException
          argument_list [53:24 - 53:48] (Main.Base.string(s...))
            ( [53:24 - 53:25] (
            call_expression [53:25 - 53:47] Main.Base.string(s...)
              field_expression [53:25 - 53:41] Main.Base.string
                field_expression [53:25 - 53:34] Main.Base
                  identifier [53:25 - 53:29] Main
                  . [53:29 - 53:30] .
                  identifier [53:30 - 53:34] Base
                . [53:34 - 53:35] .
                identifier [53:35 - 53:41] string
              argument_list [53:41 - 53:47] (s...)
                ( [53:41 - 53:42] (
                splat_expression [53:42 - 53:46] s...
                  identifier [53:42 - 53:43] s
                  ... [53:43 - 53:46] ...
                ) [53:46 - 53:47] )
            ) [53:47 - 53:48] )
        ) [53:48 - 53:49] )
    end [54:0 - 54:3] end
  string_literal [56:0 - 69:3] """
    rethrow()

Rethrow the current exception from within...
    """ [56:0 - 56:3] """
    content [56:3 - 69:0] 
    rethrow()

Rethrow the current exception from within a ...
  assignment [70:0 - 70:42] rethrow() = ccall(:jl_rethrow, Bottom, ())
    call_expression [70:0 - 70:9] rethrow()
      identifier [70:0 - 70:7] rethrow
      argument_list [70:7 - 70:9] ()
        ( [70:7 - 70:8] (
        ) [70:8 - 70:9] )
    operator [70:10 - 70:11] =
    call_expression [70:12 - 70:42] ccall(:jl_rethrow, Bottom, ())
      identifier [70:12 - 70:17] ccall
      argument_list [70:17 - 70:42] (:jl_rethrow, Bottom, ())
        ( [70:17 - 70:18] (
        quote_expression [70:18 - 70:29] :jl_rethrow
          : [70:18 - 70:19] :
          identifier [70:19 - 70:29] jl_rethrow
        , [70:29 - 70:30] ,
        identifier [70:31 - 70:37] Bottom
        , [70:37 - 70:38] ,
        tuple_expression [70:39 - 70:41] ()
          ( [70:39 - 70:40] (
          ) [70:40 - 70:41] )
        ) [70:41 - 70:42] )
  assignment [71:0 - 71:71] rethrow(@nospecialize(e)) = ccall(:jl_rethrow_other, Bottom,...
    call_expression [71:0 - 71:25] rethrow(@nospecialize(e))
      identifier [71:0 - 71:7] rethrow
      argument_list [71:7 - 71:25] (@nospecialize(e))
        ( [71:7 - 71:8] (
        macrocall_expression [71:8 - 71:24] @nospecialize(e)
          macro_identifier [71:8 - 71:21] @nospecialize
            @ [71:8 - 71:9] @
            identifier [71:9 - 71:21] nospecialize
          argument_list [71:21 - 71:24] (e)
            ( [71:21 - 71:22] (
            identifier [71:22 - 71:23] e
            ) [71:23 - 71:24] )
        ) [71:24 - 71:25] )
    operator [71:26 - 71:27] =
    call_expression [71:28 - 71:71] ccall(:jl_rethrow_other, Bottom, (Any,), e)
      identifier [71:28 - 71:33] ccall
      argument_list [71:33 - 71:71] (:jl_rethrow_other, Bottom, (Any,), e)
        ( [71:33 - 71:34] (
        quote_expression [71:34 - 71:51] :jl_rethrow_other
          : [71:34 - 71:35] :
          identifier [71:35 - 71:51] jl_rethrow_other
        , [71:51 - 71:52] ,
        identifier [71:53 - 71:59] Bottom
        , [71:59 - 71:60] ,
        tuple_expression [71:61 - 71:67] (Any,)
          ( [71:61 - 71:62] (
          identifier [71:62 - 71:65] Any
          , [71:65 - 71:66] ,
          ) [71:66 - 71:67] )
        , [71:67 - 71:68] ,
        identifier [71:69 - 71:70] e
        ) [71:70 - 71:71] )
  struct_definition [73:0 - 77:3] struct InterpreterIP
    code::Union{CodeInfo,Core.MethodIns...
    struct [73:0 - 73:6] struct
    type_head [73:7 - 73:20] InterpreterIP
      identifier [73:7 - 73:20] InterpreterIP
    typed_expression [74:4 - 74:71] code::Union{CodeInfo,Core.MethodInstance,Core.CodeInstance,N...
      identifier [74:4 - 74:8] code
      :: [74:8 - 74:10] ::
      parametrized_type_expression [74:10 - 74:71] Union{CodeInfo,Core.MethodInstance,Core.CodeInstance,Nothing...
        identifier [74:10 - 74:15] Union
        curly_expression [74:15 - 74:71] {CodeInfo,Core.MethodInstance,Core.CodeInstance,Nothing}
          { [74:15 - 74:16] {
          identifier [74:16 - 74:24] CodeInfo
          , [74:24 - 74:25] ,
          field_expression [74:25 - 74:44] Core.MethodInstance
            identifier [74:25 - 74:29] Core
            . [74:29 - 74:30] .
            identifier [74:30 - 74:44] MethodInstance
          , [74:44 - 74:45] ,
          field_expression [74:45 - 74:62] Core.CodeInstance
            identifier [74:45 - 74:49] Core
            . [74:49 - 74:50] .
            identifier [74:50 - 74:62] CodeInstance
          , [74:62 - 74:63] ,
          identifier [74:63 - 74:70] Nothing
          } [74:70 - 74:71] }
    typed_expression [75:4 - 75:17] stmt::Csize_t
      identifier [75:4 - 75:8] stmt
      :: [75:8 - 75:10] ::
      identifier [75:10 - 75:17] Csize_t
    typed_expression [76:4 - 76:30] mod::Union{Module,Nothing}
      identifier [76:4 - 76:7] mod
      :: [76:7 - 76:9] ::
      parametrized_type_expression [76:9 - 76:30] Union{Module,Nothing}
        identifier [76:9 - 76:14] Union
        curly_expression [76:14 - 76:30] {Module,Nothing}
          { [76:14 - 76:15] {
          identifier [76:15 - 76:21] Module
          , [76:21 - 76:22] ,
          identifier [76:22 - 76:29] Nothing
          } [76:29 - 76:30] }
    end [77:0 - 77:3] end
  line_comment [79:0 - 79:77] # convert dual arrays (raw bt buffer, array of GC managed va...
  line_comment [80:0 - 80:20] # array of locations
  function_definition [81:0 - 111:3] function _reformat_bt(bt::Array{Ptr{Cvoid},1}, bt2::Array{An...
    function [81:0 - 81:8] function
    signature [81:9 - 81:65] _reformat_bt(bt::Array{Ptr{Cvoid},1}, bt2::Array{Any,1})
      call_expression [81:9 - 81:65] _reformat_bt(bt::Array{Ptr{Cvoid},1}, bt2::Array{Any,1})
        identifier [81:9 - 81:21] _reformat_bt
        argument_list [81:21 - 81:65] (bt::Array{Ptr{Cvoid},1}, bt2::Array{Any,1})
          ( [81:21 - 81:22] (
          typed_expression [81:22 - 81:45] bt::Array{Ptr{Cvoid},1}
            identifier [81:22 - 81:24] bt
            :: [81:24 - 81:26] ::
            parametrized_type_expression [81:26 - 81:45] Array{Ptr{Cvoid},1}
              identifier [81:26 - 81:31] Array
              curly_expression [81:31 - 81:45] {Ptr{Cvoid},1}
                { [81:31 - 81:32] {
                parametrized_type_expression [81:32 - 81:42] Ptr{Cvoid}
                  identifier [81:32 - 81:35] Ptr
                  curly_expression [81:35 - 81:42] {Cvoid}
                    { [81:35 - 81:36] {
                    identifier [81:36 - 81:41] Cvoid
                    } [81:41 - 81:42] }
                , [81:42 - 81:43] ,
                integer_literal [81:43 - 81:44] 1
                } [81:44 - 81:45] }
          , [81:45 - 81:46] ,
          typed_expression [81:47 - 81:64] bt2::Array{Any,1}
            identifier [81:47 - 81:50] bt2
            :: [81:50 - 81:52] ::
            parametrized_type_expression [81:52 - 81:64] Array{Any,1}
              identifier [81:52 - 81:57] Array
              curly_expression [81:57 - 81:64] {Any,1}
                { [81:57 - 81:58] {
                identifier [81:58 - 81:61] Any
                , [81:61 - 81:62] ,
                integer_literal [81:62 - 81:63] 1
                } [81:63 - 81:64] }
          ) [81:64 - 81:65] )
    assignment [82:4 - 82:51] ret = Vector{Union{InterpreterIP,Ptr{Cvoid}}}()
      identifier [82:4 - 82:7] ret
      operator [82:8 - 82:9] =
      call_expression [82:10 - 82:51] Vector{Union{InterpreterIP,Ptr{Cvoid}}}()
        parametrized_type_expression [82:10 - 82:49] Vector{Union{InterpreterIP,Ptr{Cvoid}}}
          identifier [82:10 - 82:16] Vector
          curly_expression [82:16 - 82:49] {Union{InterpreterIP,Ptr{Cvoid}}}
            { [82:16 - 82:17] {
            parametrized_type_expression [82:17 - 82:48] Union{InterpreterIP,Ptr{Cvoid}}
              identifier [82:17 - 82:22] Union
              curly_expression [82:22 - 82:48] {InterpreterIP,Ptr{Cvoid}}
                { [82:22 - 82:23] {
                identifier [82:23 - 82:36] InterpreterIP
                , [82:36 - 82:37] ,
                parametrized_type_expression [82:37 - 82:47] Ptr{Cvoid}
                  identifier [82:37 - 82:40] Ptr
                  curly_expression [82:40 - 82:47] {Cvoid}
                    { [82:40 - 82:41] {
                    identifier [82:41 - 82:46] Cvoid
                    } [82:46 - 82:47] }
                } [82:47 - 82:48] }
            } [82:48 - 82:49] }
        argument_list [82:49 - 82:51] ()
          ( [82:49 - 82:50] (
          ) [82:50 - 82:51] )
    assignment [83:4 - 83:15] i, j = 1, 1
      open_tuple [83:4 - 83:8] i, j
        identifier [83:4 - 83:5] i
        , [83:5 - 83:6] ,
        identifier [83:7 - 83:8] j
      operator [83:9 - 83:10] =
      open_tuple [83:11 - 83:15] 1, 1
        integer_literal [83:11 - 83:12] 1
        , [83:12 - 83:13] ,
        integer_literal [83:14 - 83:15] 1
    while_statement [84:4 - 109:7] while i <= length(bt)
        ip = bt[i]::Ptr{Cvoid}
       ...
      while [84:4 - 84:9] while
      binary_expression [84:10 - 84:25] i <= length(bt)
        identifier [84:10 - 84:11] i
        operator [84:12 - 84:14] <=
        call_expression [84:15 - 84:25] length(bt)
          identifier [84:15 - 84:21] length
          argument_list [84:21 - 84:25] (bt)
            ( [84:21 - 84:22] (
            identifier [84:22 - 84:24] bt
            ) [84:24 - 84:25] )
      assignment [85:8 - 85:30] ip = bt[i]::Ptr{Cvoid}
        identifier [85:8 - 85:10] ip
        operator [85:11 - 85:12] =
        typed_expression [85:13 - 85:30] bt[i]::Ptr{Cvoid}
          index_expression [85:13 - 85:18] bt[i]
            identifier [85:13 - 85:15] bt
            vector_expression [85:15 - 85:18] [i]
              [ [85:15 - 85:16] [
              identifier [85:16 - 85:17] i
              ] [85:17 - 85:18] ]
          :: [85:18 - 85:20] ::
          parametrized_type_expression [85:20 - 85:30] Ptr{Cvoid}
            identifier [85:20 - 85:23] Ptr
            curly_expression [85:23 - 85:30] {Cvoid}
              { [85:23 - 85:24] {
              identifier [85:24 - 85:29] Cvoid
              } [85:29 - 85:30] }
      if_statement [86:8 - 91:11] if UInt(ip) != (-1 % UInt) # See also jl_bt_is_native
      ...
        if [86:8 - 86:10] if
        binary_expression [86:11 - 86:34] UInt(ip) != (-1 % UInt)
          call_expression [86:11 - 86:19] UInt(ip)
            identifier [86:11 - 86:15] UInt
            argument_list [86:15 - 86:19] (ip)
              ( [86:15 - 86:16] (
              identifier [86:16 - 86:18] ip
              ) [86:18 - 86:19] )
          operator [86:20 - 86:22] !=
          parenthesized_expression [86:23 - 86:34] (-1 % UInt)
            ( [86:23 - 86:24] (
            binary_expression [86:24 - 86:33] -1 % UInt
              unary_expression [86:24 - 86:26] -1
                operator [86:24 - 86:25] -
                integer_literal [86:25 - 86:26] 1
              operator [86:27 - 86:28] %
              identifier [86:29 - 86:33] UInt
            ) [86:33 - 86:34] )
        line_comment [86:35 - 86:61] # See also jl_bt_is_native
        line_comment [87:12 - 87:26] # native frame
        call_expression [88:12 - 88:26] push!(ret, ip)
          identifier [88:12 - 88:17] push!
          argument_list [88:17 - 88:26] (ret, ip)
            ( [88:17 - 88:18] (
            identifier [88:18 - 88:21] ret
            , [88:21 - 88:22] ,
            identifier [88:23 - 88:25] ip
            ) [88:25 - 88:26] )
        compound_assignment_expression [89:12 - 89:18] i += 1
          identifier [89:12 - 89:13] i
          operator [89:14 - 89:16] +=
          integer_literal [89:17 - 89:18] 1
        continue_statement [90:12 - 90:20] continue
        end [91:8 - 91:11] end
      line_comment [92:8 - 92:34] # Extended backtrace entry
      assignment [93:8 - 93:57] entry_metadata = reinterpret(UInt, bt[i+1])::UInt
        identifier [93:8 - 93:22] entry_metadata
        operator [93:23 - 93:24] =
        typed_expression [93:25 - 93:57] reinterpret(UInt, bt[i+1])::UInt
          call_expression [93:25 - 93:51] reinterpret(UInt, bt[i+1])
            identifier [93:25 - 93:36] reinterpret
            argument_list [93:36 - 93:51] (UInt, bt[i+1])
              ( [93:36 - 93:37] (
              identifier [93:37 - 93:41] UInt
              , [93:41 - 93:42] ,
              index_expression [93:43 - 93:50] bt[i+1]
                identifier [93:43 - 93:45] bt
                vector_expression [93:45 - 93:50] [i+1]
                  [ [93:45 - 93:46] [
                  binary_expression [93:46 - 93:49] i+1
                    identifier [93:46 - 93:47] i
                    operator [93:47 - 93:48] +
                    integer_literal [93:48 - 93:49] 1
                  ] [93:49 - 93:50] ]
              ) [93:50 - 93:51] )
          :: [93:51 - 93:53] ::
          identifier [93:53 - 93:57] UInt
      assignment [94:8 - 94:41] njlvalues =  entry_metadata & 0x7
        identifier [94:8 - 94:17] njlvalues
        operator [94:18 - 94:19] =
        binary_expression [94:21 - 94:41] entry_metadata & 0x7
          identifier [94:21 - 94:35] entry_metadata
          operator [94:36 - 94:37] &
          integer_literal [94:38 - 94:41] 0x7
      assignment [95:8 - 95:47] nuintvals = (entry_metadata >> 3) & 0x7
        identifier [95:8 - 95:17] nuintvals
        operator [95:18 - 95:19] =
        binary_expression [95:20 - 95:47] (entry_metadata >> 3) & 0x7
          parenthesized_expression [95:20 - 95:41] (entry_metadata >> 3)
            ( [95:20 - 95:21] (
            binary_expression [95:21 - 95:40] entry_metadata >> 3
              identifier [95:21 - 95:35] entry_metadata
              operator [95:36 - 95:38] >>
              integer_literal [95:39 - 95:40] 3
            ) [95:40 - 95:41] )
          operator [95:42 - 95:43] &
          integer_literal [95:44 - 95:47] 0x7
      assignment [96:8 - 96:47] tag       = (entry_metadata >> 6) & 0xf
        identifier [96:8 - 96:11] tag
        operator [96:18 - 96:19] =
        binary_expression [96:20 - 96:47] (entry_metadata >> 6) & 0xf
          parenthesized_expression [96:20 - 96:41] (entry_metadata >> 6)
            ( [96:20 - 96:21] (
            binary_expression [96:21 - 96:40] entry_metadata >> 6
              identifier [96:21 - 96:35] entry_metadata
              operator [96:36 - 96:38] >>
              integer_literal [96:39 - 96:40] 6
            ) [96:40 - 96:41] )
          operator [96:42 - 96:43] &
          integer_literal [96:44 - 96:47] 0xf
      assignment [97:8 - 97:41] header    =  entry_metadata >> 10
        identifier [97:8 - 97:14] header
        operator [97:18 - 97:19] =
        binary_expression [97:21 - 97:41] entry_metadata >> 10
          identifier [97:21 - 97:35] entry_metadata
          operator [97:36 - 97:38] >>
          integer_literal [97:39 - 97:41] 10
      if_statement [98:8 - 105:11] if tag == 1 # JL_BT_INTERP_FRAME_TAG
            code = bt2[...
        if [98:8 - 98:10] if
        binary_expression [98:11 - 98:19] tag == 1
          identifier [98:11 - 98:14] tag
          operator [98:15 - 98:17] ==
          integer_literal [98:18 - 98:19] 1
        line_comment [98:20 - 98:44] # JL_BT_INTERP_FRAME_TAG
        assignment [99:12 - 99:88] code = bt2[j]::Union{CodeInfo,Core.MethodInstance,Core.CodeI...
          identifier [99:12 - 99:16] code
          operator [99:17 - 99:18] =
          typed_expression [99:19 - 99:88] bt2[j]::Union{CodeInfo,Core.MethodInstance,Core.CodeInstance...
            index_expression [99:19 - 99:25] bt2[j]
              identifier [99:19 - 99:22] bt2
              vector_expression [99:22 - 99:25] [j]
                [ [99:22 - 99:23] [
                identifier [99:23 - 99:24] j
                ] [99:24 - 99:25] ]
            :: [99:25 - 99:27] ::
            parametrized_type_expression [99:27 - 99:88] Union{CodeInfo,Core.MethodInstance,Core.CodeInstance,Nothing...
              identifier [99:27 - 99:32] Union
              curly_expression [99:32 - 99:88] {CodeInfo,Core.MethodInstance,Core.CodeInstance,Nothing}
                { [99:32 - 99:33] {
                identifier [99:33 - 99:41] CodeInfo
                , [99:41 - 99:42] ,
                field_expression [99:42 - 99:61] Core.MethodInstance
                  identifier [99:42 - 99:46] Core
                  . [99:46 - 99:47] .
                  identifier [99:47 - 99:61] MethodInstance
                , [99:61 - 99:62] ,
                field_expression [99:62 - 99:79] Core.CodeInstance
                  identifier [99:62 - 99:66] Core
                  . [99:66 - 99:67] .
                  identifier [99:67 - 99:79] CodeInstance
                , [99:79 - 99:80] ,
                identifier [99:80 - 99:87] Nothing
                } [99:87 - 99:88] }
        assignment [100:12 - 100:76] mod = njlvalues == 2 ? bt2[j+1]::Union{Module,Nothing} : not...
          identifier [100:12 - 100:15] mod
          operator [100:16 - 100:17] =
          ternary_expression [100:18 - 100:76] njlvalues == 2 ? bt2[j+1]::Union{Module,Nothing} : nothing
            binary_expression [100:18 - 100:32] njlvalues == 2
              identifier [100:18 - 100:27] njlvalues
              operator [100:28 - 100:30] ==
              integer_literal [100:31 - 100:32] 2
            ? [100:33 - 100:34] ?
            typed_expression [100:35 - 100:66] bt2[j+1]::Union{Module,Nothing}
              index_expression [100:35 - 100:43] bt2[j+1]
                identifier [100:35 - 100:38] bt2
                vector_expression [100:38 - 100:43] [j+1]
                  [ [100:38 - 100:39] [
                  binary_expression [100:39 - 100:42] j+1
                    identifier [100:39 - 100:40] j
                    operator [100:40 - 100:41] +
                    integer_literal [100:41 - 100:42] 1
                  ] [100:42 - 100:43] ]
              :: [100:43 - 100:45] ::
              parametrized_type_expression [100:45 - 100:66] Union{Module,Nothing}
                identifier [100:45 - 100:50] Union
                curly_expression [100:50 - 100:66] {Module,Nothing}
                  { [100:50 - 100:51] {
                  identifier [100:51 - 100:57] Module
                  , [100:57 - 100:58] ,
                  identifier [100:58 - 100:65] Nothing
                  } [100:65 - 100:66] }
            : [100:67 - 100:68] :
            identifier [100:69 - 100:76] nothing
        call_expression [101:12 - 101:56] push!(ret, InterpreterIP(code, header, mod))
          identifier [101:12 - 101:17] push!
          argument_list [101:17 - 101:56] (ret, InterpreterIP(code, header, mod))
            ( [101:17 - 101:18] (
            identifier [101:18 - 101:21] ret
            , [101:21 - 101:22] ,
            call_expression [101:23 - 101:55] InterpreterIP(code, header, mod)
              identifier [101:23 - 101:36] InterpreterIP
              argument_list [101:36 - 101:55] (code, header, mod)
                ( [101:36 - 101:37] (
                identifier [101:37 - 101:41] code
                , [101:41 - 101:42] ,
                identifier [101:43 - 101:49] header
                , [101:49 - 101:50] ,
                identifier [101:51 - 101:54] mod
                ) [101:54 - 101:55] )
            ) [101:55 - 101:56] )
        else_clause [102:8 - 105:0] else
            # Tags we don't know about are an error
   ...
          else [102:8 - 102:12] else
          line_comment [103:12 - 103:51] # Tags we don't know about are an error
          call_expression [104:12 - 104:90] throw(ArgumentError("Unexpected extended backtrace entry tag...
            identifier [104:12 - 104:17] throw
            argument_list [104:17 - 104:90] (ArgumentError("Unexpected extended backtrace entry tag $tag...
              ( [104:17 - 104:18] (
              call_expression [104:18 - 104:89] ArgumentError("Unexpected extended backtrace entry tag $tag ...
                identifier [104:18 - 104:31] ArgumentError
                argument_list [104:31 - 104:89] ("Unexpected extended backtrace entry tag $tag at bt[$i]")
                  ( [104:31 - 104:32] (
                  string_literal [104:32 - 104:88] "Unexpected extended backtrace entry tag $tag at bt[$i]"
                    " [104:32 - 104:33] "
                    content [104:33 - 104:73] Unexpected extended backtrace entry tag 
                    string_interpolation [104:73 - 104:77] $tag
                      $ [104:73 - 104:74] $
                      identifier [104:74 - 104:77] tag
                    content [104:77 - 104:84]  at bt[
                    string_interpolation [104:84 - 104:86] $i
                      $ [104:84 - 104:85] $
                      identifier [104:85 - 104:86] i
                    content [104:86 - 104:87] ]
                  ) [104:88 - 104:89] )
              ) [104:89 - 104:90] )
        end [105:8 - 105:11] end
      line_comment [106:8 - 106:30] # See jl_bt_entry_size
      compound_assignment_expression [107:8 - 107:27] j += Int(njlvalues)
        identifier [107:8 - 107:9] j
        operator [107:10 - 107:12] +=
        call_expression [107:13 - 107:27] Int(njlvalues)
          identifier [107:13 - 107:16] Int
          argument_list [107:16 - 107:27] (njlvalues)
            ( [107:16 - 107:17] (
            identifier [107:17 - 107:26] njlvalues
            ) [107:26 - 107:27] )
      compound_assignment_expression [108:8 - 108:43] i += 2 + Int(njlvalues + nuintvals)
        identifier [108:8 - 108:9] i
        operator [108:10 - 108:12] +=
        binary_expression [108:13 - 108:43] 2 + Int(njlvalues + nuintvals)
          integer_literal [108:13 - 108:14] 2
          operator [108:15 - 108:16] +
          call_expression [108:17 - 108:43] Int(njlvalues + nuintvals)
            identifier [108:17 - 108:20] Int
            argument_list [108:20 - 108:43] (njlvalues + nuintvals)
              ( [108:20 - 108:21] (
              binary_expression [108:21 - 108:42] njlvalues + nuintvals
                identifier [108:21 - 108:30] njlvalues
                operator [108:31 - 108:32] +
                identifier [108:33 - 108:42] nuintvals
              ) [108:42 - 108:43] )
      end [109:4 - 109:7] end
    identifier [110:4 - 110:7] ret
    end [111:0 - 111:3] end
  string_literal [113:0 - 117:3] """
    backtrace()

Get a backtrace object for the current ...
    """ [113:0 - 113:3] """
    content [113:3 - 117:0] 
    backtrace()

Get a backtrace object for the current pro...
  function_definition [118:0 - 125:3] function backtrace()
    @noinline
    # skip frame for back...
    function [118:0 - 118:8] function
    signature [118:9 - 118:20] backtrace()
      call_expression [118:9 - 118:20] backtrace()
        identifier [118:9 - 118:18] backtrace
        argument_list [118:18 - 118:20] ()
          ( [118:18 - 118:19] (
          ) [118:19 - 118:20] )
    macrocall_expression [119:4 - 119:13] @noinline
      macro_identifier [119:4 - 119:13] @noinline
        @ [119:4 - 119:5] @
        identifier [119:5 - 119:13] noinline
    line_comment [120:4 - 120:70] # skip frame for backtrace(). Note that for this to work pro...
    line_comment [121:4 - 121:61] # backtrace() itself must not be interpreted nor inlined.
    assignment [122:4 - 122:12] skip = 1
      identifier [122:4 - 122:8] skip
      operator [122:9 - 122:10] =
      integer_literal [122:11 - 122:12] 1
    assignment [123:4 - 123:91] bt1, bt2 = ccall(:jl_backtrace_from_here, Ref{SimpleVector},...
      open_tuple [123:4 - 123:12] bt1, bt2
        identifier [123:4 - 123:7] bt1
        , [123:7 - 123:8] ,
        identifier [123:9 - 123:12] bt2
      operator [123:13 - 123:14] =
      call_expression [123:15 - 123:91] ccall(:jl_backtrace_from_here, Ref{SimpleVector}, (Cint, Cin...
        identifier [123:15 - 123:20] ccall
        argument_list [123:20 - 123:91] (:jl_backtrace_from_here, Ref{SimpleVector}, (Cint, Cint), f...
          ( [123:20 - 123:21] (
          quote_expression [123:21 - 123:44] :jl_backtrace_from_here
            : [123:21 - 123:22] :
            identifier [123:22 - 123:44] jl_backtrace_from_here
          , [123:44 - 123:45] ,
          parametrized_type_expression [123:46 - 123:63] Ref{SimpleVector}
            identifier [123:46 - 123:49] Ref
            curly_expression [123:49 - 123:63] {SimpleVector}
              { [123:49 - 123:50] {
              identifier [123:50 - 123:62] SimpleVector
              } [123:62 - 123:63] }
          , [123:63 - 123:64] ,
          tuple_expression [123:65 - 123:77] (Cint, Cint)
            ( [123:65 - 123:66] (
            identifier [123:66 - 123:70] Cint
            , [123:70 - 123:71] ,
            identifier [123:72 - 123:76] Cint
            ) [123:76 - 123:77] )
          , [123:77 - 123:78] ,
          boolean_literal [123:79 - 123:84] false
            false [123:79 - 123:84] false
          , [123:84 - 123:85] ,
          identifier [123:86 - 123:90] skip
          ) [123:90 - 123:91] )
    return_statement [124:4 - 124:66] return _reformat_bt(bt1::Vector{Ptr{Cvoid}}, bt2::Vector{Any...
      return [124:4 - 124:10] return
      call_expression [124:11 - 124:66] _reformat_bt(bt1::Vector{Ptr{Cvoid}}, bt2::Vector{Any})
        identifier [124:11 - 124:23] _reformat_bt
        argument_list [124:23 - 124:66] (bt1::Vector{Ptr{Cvoid}}, bt2::Vector{Any})
          ( [124:23 - 124:24] (
          typed_expression [124:24 - 124:47] bt1::Vector{Ptr{Cvoid}}
            identifier [124:24 - 124:27] bt1
            :: [124:27 - 124:29] ::
            parametrized_type_expression [124:29 - 124:47] Vector{Ptr{Cvoid}}
              identifier [124:29 - 124:35] Vector
              curly_expression [124:35 - 124:47] {Ptr{Cvoid}}
                { [124:35 - 124:36] {
                parametrized_type_expression [124:36 - 124:46] Ptr{Cvoid}
                  identifier [124:36 - 124:39] Ptr
                  curly_expression [124:39 - 124:46] {Cvoid}
                    { [124:39 - 124:40] {
                    identifier [124:40 - 124:45] Cvoid
                    } [124:45 - 124:46] }
                } [124:46 - 124:47] }
          , [124:47 - 124:48] ,
          typed_expression [124:49 - 124:65] bt2::Vector{Any}
            identifier [124:49 - 124:52] bt2
            :: [124:52 - 124:54] ::
            parametrized_type_expression [124:54 - 124:65] Vector{Any}
              identifier [124:54 - 124:60] Vector
              curly_expression [124:60 - 124:65] {Any}
                { [124:60 - 124:61] {
                identifier [124:61 - 124:64] Any
                } [124:64 - 124:65] }
          ) [124:65 - 124:66] )
    end [125:0 - 125:3] end
  string_literal [127:0 - 131:3] """
    catch_backtrace()

Get the backtrace of the current ...
    """ [127:0 - 127:3] """
    content [127:3 - 131:0] 
    catch_backtrace()

Get the backtrace of the current exc...
  function_definition [132:0 - 135:3] function catch_backtrace()
    bt, bt2 = ccall(:jl_get_backt...
    function [132:0 - 132:8] function
    signature [132:9 - 132:26] catch_backtrace()
      call_expression [132:9 - 132:26] catch_backtrace()
        identifier [132:9 - 132:24] catch_backtrace
        argument_list [132:24 - 132:26] ()
          ( [132:24 - 132:25] (
          ) [132:25 - 132:26] )
    assignment [133:4 - 133:61] bt, bt2 = ccall(:jl_get_backtrace, Ref{SimpleVector}, ())
      open_tuple [133:4 - 133:11] bt, bt2
        identifier [133:4 - 133:6] bt
        , [133:6 - 133:7] ,
        identifier [133:8 - 133:11] bt2
      operator [133:12 - 133:13] =
      call_expression [133:14 - 133:61] ccall(:jl_get_backtrace, Ref{SimpleVector}, ())
        identifier [133:14 - 133:19] ccall
        argument_list [133:19 - 133:61] (:jl_get_backtrace, Ref{SimpleVector}, ())
          ( [133:19 - 133:20] (
          quote_expression [133:20 - 133:37] :jl_get_backtrace
            : [133:20 - 133:21] :
            identifier [133:21 - 133:37] jl_get_backtrace
          , [133:37 - 133:38] ,
          parametrized_type_expression [133:39 - 133:56] Ref{SimpleVector}
            identifier [133:39 - 133:42] Ref
            curly_expression [133:42 - 133:56] {SimpleVector}
              { [133:42 - 133:43] {
              identifier [133:43 - 133:55] SimpleVector
              } [133:55 - 133:56] }
          , [133:56 - 133:57] ,
          tuple_expression [133:58 - 133:60] ()
            ( [133:58 - 133:59] (
            ) [133:59 - 133:60] )
          ) [133:60 - 133:61] )
    return_statement [134:4 - 134:65] return _reformat_bt(bt::Vector{Ptr{Cvoid}}, bt2::Vector{Any}...
      return [134:4 - 134:10] return
      call_expression [134:11 - 134:65] _reformat_bt(bt::Vector{Ptr{Cvoid}}, bt2::Vector{Any})
        identifier [134:11 - 134:23] _reformat_bt
        argument_list [134:23 - 134:65] (bt::Vector{Ptr{Cvoid}}, bt2::Vector{Any})
          ( [134:23 - 134:24] (
          typed_expression [134:24 - 134:46] bt::Vector{Ptr{Cvoid}}
            identifier [134:24 - 134:26] bt
            :: [134:26 - 134:28] ::
            parametrized_type_expression [134:28 - 134:46] Vector{Ptr{Cvoid}}
              identifier [134:28 - 134:34] Vector
              curly_expression [134:34 - 134:46] {Ptr{Cvoid}}
                { [134:34 - 134:35] {
                parametrized_type_expression [134:35 - 134:45] Ptr{Cvoid}
                  identifier [134:35 - 134:38] Ptr
                  curly_expression [134:38 - 134:45] {Cvoid}
                    { [134:38 - 134:39] {
                    identifier [134:39 - 134:44] Cvoid
                    } [134:44 - 134:45] }
                } [134:45 - 134:46] }
          , [134:46 - 134:47] ,
          typed_expression [134:48 - 134:64] bt2::Vector{Any}
            identifier [134:48 - 134:51] bt2
            :: [134:51 - 134:53] ::
            parametrized_type_expression [134:53 - 134:64] Vector{Any}
              identifier [134:53 - 134:59] Vector
              curly_expression [134:59 - 134:64] {Any}
                { [134:59 - 134:60] {
                identifier [134:60 - 134:63] Any
                } [134:63 - 134:64] }
          ) [134:64 - 134:65] )
    end [135:0 - 135:3] end
  struct_definition [137:0 - 139:3] struct ExceptionStack <: AbstractArray{Any,1}
    stack::Arr...
    struct [137:0 - 137:6] struct
    type_head [137:7 - 137:45] ExceptionStack <: AbstractArray{Any,1}
      binary_expression [137:7 - 137:45] ExceptionStack <: AbstractArray{Any,1}
        identifier [137:7 - 137:21] ExceptionStack
        operator [137:22 - 137:24] <:
        parametrized_type_expression [137:25 - 137:45] AbstractArray{Any,1}
          identifier [137:25 - 137:38] AbstractArray
          curly_expression [137:38 - 137:45] {Any,1}
            { [137:38 - 137:39] {
            identifier [137:39 - 137:42] Any
            , [137:42 - 137:43] ,
            integer_literal [137:43 - 137:44] 1
            } [137:44 - 137:45] }
    typed_expression [138:4 - 138:23] stack::Array{Any,1}
      identifier [138:4 - 138:9] stack
      :: [138:9 - 138:11] ::
      parametrized_type_expression [138:11 - 138:23] Array{Any,1}
        identifier [138:11 - 138:16] Array
        curly_expression [138:16 - 138:23] {Any,1}
          { [138:16 - 138:17] {
          identifier [138:17 - 138:20] Any
          , [138:20 - 138:21] ,
          integer_literal [138:21 - 138:22] 1
          } [138:22 - 138:23] }
    end [139:0 - 139:3] end
  string_literal [141:0 - 158:3] """
    current_exceptions(task::Task=current_task(); [backt...
    """ [141:0 - 141:3] """
    content [141:3 - 158:0] 
    current_exceptions(task::Task=current_task(); [backtrac...
  function_definition [159:0 - 169:3] function current_exceptions(task::Task=current_task(); backt...
    function [159:0 - 159:8] function
    signature [159:9 - 159:76] current_exceptions(task::Task=current_task(); backtrace::Boo...
      call_expression [159:9 - 159:76] current_exceptions(task::Task=current_task(); backtrace::Boo...
        identifier [159:9 - 159:27] current_exceptions
        argument_list [159:27 - 159:76] (task::Task=current_task(); backtrace::Bool=true)
          ( [159:27 - 159:28] (
          named_argument [159:28 - 159:53] task::Task=current_task()
            typed_expression [159:28 - 159:38] task::Task
              identifier [159:28 - 159:32] task
              :: [159:32 - 159:34] ::
              identifier [159:34 - 159:38] Task
            operator [159:38 - 159:39] =
            call_expression [159:39 - 159:53] current_task()
              identifier [159:39 - 159:51] current_task
              argument_list [159:51 - 159:53] ()
                ( [159:51 - 159:52] (
                ) [159:52 - 159:53] )
          ; [159:53 - 159:54] ;
          named_argument [159:55 - 159:75] backtrace::Bool=true
            typed_expression [159:55 - 159:70] backtrace::Bool
              identifier [159:55 - 159:64] backtrace
              :: [159:64 - 159:66] ::
              identifier [159:66 - 159:70] Bool
            operator [159:70 - 159:71] =
            boolean_literal [159:71 - 159:75] true
              true [159:71 - 159:75] true
          ) [159:75 - 159:76] )
    assignment [160:4 - 160:100] raw = ccall(:jl_get_excstack, Any, (Any,Cint,Cint), task, ba...
      identifier [160:4 - 160:7] raw
      operator [160:8 - 160:9] =
      typed_expression [160:10 - 160:100] ccall(:jl_get_excstack, Any, (Any,Cint,Cint), task, backtrac...
        call_expression [160:10 - 160:87] ccall(:jl_get_excstack, Any, (Any,Cint,Cint), task, backtrac...
          identifier [160:10 - 160:15] ccall
          argument_list [160:15 - 160:87] (:jl_get_excstack, Any, (Any,Cint,Cint), task, backtrace, ty...
            ( [160:15 - 160:16] (
            quote_expression [160:16 - 160:32] :jl_get_excstack
              : [160:16 - 160:17] :
              identifier [160:17 - 160:32] jl_get_excstack
            , [160:32 - 160:33] ,
            identifier [160:34 - 160:37] Any
            , [160:37 - 160:38] ,
            tuple_expression [160:39 - 160:54] (Any,Cint,Cint)
              ( [160:39 - 160:40] (
              identifier [160:40 - 160:43] Any
              , [160:43 - 160:44] ,
              identifier [160:44 - 160:48] Cint
              , [160:48 - 160:49] ,
              identifier [160:49 - 160:53] Cint
              ) [160:53 - 160:54] )
            , [160:54 - 160:55] ,
            identifier [160:56 - 160:60] task
            , [160:60 - 160:61] ,
            identifier [160:62 - 160:71] backtrace
            , [160:71 - 160:72] ,
            call_expression [160:73 - 160:86] typemax(Cint)
              identifier [160:73 - 160:80] typemax
              argument_list [160:80 - 160:86] (Cint)
                ( [160:80 - 160:81] (
                identifier [160:81 - 160:85] Cint
                ) [160:85 - 160:86] )
            ) [160:86 - 160:87] )
        :: [160:87 - 160:89] ::
        parametrized_type_expression [160:89 - 160:100] Vector{Any}
          identifier [160:89 - 160:95] Vector
          curly_expression [160:95 - 160:100] {Any}
            { [160:95 - 160:96] {
            identifier [160:96 - 160:99] Any
            } [160:99 - 160:100] }
    assignment [161:4 - 161:21] formatted = Any[]
      identifier [161:4 - 161:13] formatted
      operator [161:14 - 161:15] =
      index_expression [161:16 - 161:21] Any[]
        identifier [161:16 - 161:19] Any
        vector_expression [161:19 - 161:21] []
          [ [161:19 - 161:20] [
          ] [161:20 - 161:21] ]
    assignment [162:4 - 162:30] stride = backtrace ? 3 : 1
      identifier [162:4 - 162:10] stride
      operator [162:11 - 162:12] =
      ternary_expression [162:13 - 162:30] backtrace ? 3 : 1
        identifier [162:13 - 162:22] backtrace
        ? [162:23 - 162:24] ?
        integer_literal [162:25 - 162:26] 3
        : [162:27 - 162:28] :
        integer_literal [162:29 - 162:30] 1
    for_statement [163:4 - 167:7] for i = reverse(1:stride:length(raw))
        exc = raw[i]
 ...
      for [163:4 - 163:7] for
      for_binding [163:8 - 163:41] i = reverse(1:stride:length(raw))
        identifier [163:8 - 163:9] i
        operator [163:10 - 163:11] =
        call_expression [163:12 - 163:41] reverse(1:stride:length(raw))
          identifier [163:12 - 163:19] reverse
          argument_list [163:19 - 163:41] (1:stride:length(raw))
            ( [163:19 - 163:20] (
            range_expression [163:20 - 163:40] 1:stride:length(raw)
              range_expression [163:20 - 163:28] 1:stride
                integer_literal [163:20 - 163:21] 1
                : [163:21 - 163:22] :
                identifier [163:22 - 163:28] stride
              : [163:28 - 163:29] :
              call_expression [163:29 - 163:40] length(raw)
                identifier [163:29 - 163:35] length
                argument_list [163:35 - 163:40] (raw)
                  ( [163:35 - 163:36] (
                  identifier [163:36 - 163:39] raw
                  ) [163:39 - 163:40] )
            ) [163:40 - 163:41] )
      assignment [164:8 - 164:20] exc = raw[i]
        identifier [164:8 - 164:11] exc
        operator [164:12 - 164:13] =
        index_expression [164:14 - 164:20] raw[i]
          identifier [164:14 - 164:17] raw
          vector_expression [164:17 - 164:20] [i]
            [ [164:17 - 164:18] [
            identifier [164:18 - 164:19] i
            ] [164:19 - 164:20] ]
      assignment [165:8 - 165:71] bt = backtrace ? Base._reformat_bt(raw[i+1],raw[i+2]) : noth...
        identifier [165:8 - 165:10] bt
        operator [165:11 - 165:12] =
        ternary_expression [165:13 - 165:71] backtrace ? Base._reformat_bt(raw[i+1],raw[i+2]) : nothing
          identifier [165:13 - 165:22] backtrace
          ? [165:23 - 165:24] ?
          call_expression [165:25 - 165:61] Base._reformat_bt(raw[i+1],raw[i+2])
            field_expression [165:25 - 165:42] Base._reformat_bt
              identifier [165:25 - 165:29] Base
              . [165:29 - 165:30] .
              identifier [165:30 - 165:42] _reformat_bt
            argument_list [165:42 - 165:61] (raw[i+1],raw[i+2])
              ( [165:42 - 165:43] (
              index_expression [165:43 - 165:51] raw[i+1]
                identifier [165:43 - 165:46] raw
                vector_expression [165:46 - 165:51] [i+1]
                  [ [165:46 - 165:47] [
                  binary_expression [165:47 - 165:50] i+1
                    identifier [165:47 - 165:48] i
                    operator [165:48 - 165:49] +
                    integer_literal [165:49 - 165:50] 1
                  ] [165:50 - 165:51] ]
              , [165:51 - 165:52] ,
              index_expression [165:52 - 165:60] raw[i+2]
                identifier [165:52 - 165:55] raw
                vector_expression [165:55 - 165:60] [i+2]
                  [ [165:55 - 165:56] [
                  binary_expression [165:56 - 165:59] i+2
                    identifier [165:56 - 165:57] i
                    operator [165:57 - 165:58] +
                    integer_literal [165:58 - 165:59] 2
                  ] [165:59 - 165:60] ]
              ) [165:60 - 165:61] )
          : [165:62 - 165:63] :
          identifier [165:64 - 165:71] nothing
      call_expression [166:8 - 166:54] push!(formatted, (exception=exc,backtrace=bt))
        identifier [166:8 - 166:13] push!
        argument_list [166:13 - 166:54] (formatted, (exception=exc,backtrace=bt))
          ( [166:13 - 166:14] (
          identifier [166:14 - 166:23] formatted
          , [166:23 - 166:24] ,
          tuple_expression [166:25 - 166:53] (exception=exc,backtrace=bt)
            ( [166:25 - 166:26] (
            named_field [166:26 - 166:39] exception=exc
              identifier [166:26 - 166:35] exception
              = [166:35 - 166:36] =
              identifier [166:36 - 166:39] exc
            , [166:39 - 166:40] ,
            named_field [166:40 - 166:52] backtrace=bt
              identifier [166:40 - 166:49] backtrace
              = [166:49 - 166:50] =
              identifier [166:50 - 166:52] bt
            ) [166:52 - 166:53] )
          ) [166:53 - 166:54] )
      end [167:4 - 167:7] end
    call_expression [168:4 - 168:29] ExceptionStack(formatted)
      identifier [168:4 - 168:18] ExceptionStack
      argument_list [168:18 - 168:29] (formatted)
        ( [168:18 - 168:19] (
        identifier [168:19 - 168:28] formatted
        ) [168:28 - 168:29] )
    end [169:0 - 169:3] end
  line_comment [171:0 - 171:50] ## keyword arg lowering generates calls to this ##
  function_definition [172:0 - 175:3] function kwerr(kw, args::Vararg{Any,N}) where {N}
    @noinl...
    function [172:0 - 172:8] function
    signature [172:9 - 172:49] kwerr(kw, args::Vararg{Any,N}) where {N}
      where_expression [172:9 - 172:49] kwerr(kw, args::Vararg{Any,N}) where {N}
        call_expression [172:9 - 172:39] kwerr(kw, args::Vararg{Any,N})
          identifier [172:9 - 172:14] kwerr
          argument_list [172:14 - 172:39] (kw, args::Vararg{Any,N})
            ( [172:14 - 172:15] (
            identifier [172:15 - 172:17] kw
            , [172:17 - 172:18] ,
            typed_expression [172:19 - 172:38] args::Vararg{Any,N}
              identifier [172:19 - 172:23] args
              :: [172:23 - 172:25] ::
              parametrized_type_expression [172:25 - 172:38] Vararg{Any,N}
                identifier [172:25 - 172:31] Vararg
                curly_expression [172:31 - 172:38] {Any,N}
                  { [172:31 - 172:32] {
                  identifier [172:32 - 172:35] Any
                  , [172:35 - 172:36] ,
                  identifier [172:36 - 172:37] N
                  } [172:37 - 172:38] }
            ) [172:38 - 172:39] )
        where [172:40 - 172:45] where
        curly_expression [172:46 - 172:49] {N}
          { [172:46 - 172:47] {
          identifier [172:47 - 172:48] N
          } [172:48 - 172:49] }
    macrocall_expression [173:4 - 173:13] @noinline
      macro_identifier [173:4 - 173:13] @noinline
        @ [173:4 - 173:5] @
        identifier [173:5 - 173:13] noinline
    call_expression [174:4 - 174:67] throw(MethodError(Core.kwcall, (kw, args...), tls_world_age(...
      identifier [174:4 - 174:9] throw
      argument_list [174:9 - 174:67] (MethodError(Core.kwcall, (kw, args...), tls_world_age()))
        ( [174:9 - 174:10] (
        call_expression [174:10 - 174:66] MethodError(Core.kwcall, (kw, args...), tls_world_age())
          identifier [174:10 - 174:21] MethodError
          argument_list [174:21 - 174:66] (Core.kwcall, (kw, args...), tls_world_age())
            ( [174:21 - 174:22] (
            field_expression [174:22 - 174:33] Core.kwcall
              identifier [174:22 - 174:26] Core
              . [174:26 - 174:27] .
              identifier [174:27 - 174:33] kwcall
            , [174:33 - 174:34] ,
            tuple_expression [174:35 - 174:48] (kw, args...)
              ( [174:35 - 174:36] (
              identifier [174:36 - 174:38] kw
              , [174:38 - 174:39] ,
              splat_expression [174:40 - 174:47] args...
                identifier [174:40 - 174:44] args
                ... [174:44 - 174:47] ...
              ) [174:47 - 174:48] )
            , [174:48 - 174:49] ,
            call_expression [174:50 - 174:65] tls_world_age()
              identifier [174:50 - 174:63] tls_world_age
              argument_list [174:63 - 174:65] ()
                ( [174:63 - 174:64] (
                ) [174:64 - 174:65] )
            ) [174:65 - 174:66] )
        ) [174:66 - 174:67] )
    end [175:0 - 175:3] end
  line_comment [177:0 - 177:27] ## system error handling ##
  string_literal [178:0 - 183:3] """
    systemerror(sysfunc[, errno::Cint=Libc.errno()])
   ...
    """ [178:0 - 178:3] """
    content [178:3 - 183:0] 
    systemerror(sysfunc[, errno::Cint=Libc.errno()])
    sy...
  assignment [184:0 - 184:94] systemerror(p, b::Bool; extrainfo=nothing) = b ? systemerror...
    call_expression [184:0 - 184:42] systemerror(p, b::Bool; extrainfo=nothing)
      identifier [184:0 - 184:11] systemerror
      argument_list [184:11 - 184:42] (p, b::Bool; extrainfo=nothing)
        ( [184:11 - 184:12] (
        identifier [184:12 - 184:13] p
        , [184:13 - 184:14] ,
        typed_expression [184:15 - 184:22] b::Bool
          identifier [184:15 - 184:16] b
          :: [184:16 - 184:18] ::
          identifier [184:18 - 184:22] Bool
        ; [184:22 - 184:23] ;
        named_argument [184:24 - 184:41] extrainfo=nothing
          identifier [184:24 - 184:33] extrainfo
          operator [184:33 - 184:34] =
          identifier [184:34 - 184:41] nothing
        ) [184:41 - 184:42] )
    operator [184:43 - 184:44] =
    ternary_expression [184:45 - 184:94] b ? systemerror(p, extrainfo=extrainfo) : nothing
      identifier [184:45 - 184:46] b
      ? [184:47 - 184:48] ?
      call_expression [184:49 - 184:84] systemerror(p, extrainfo=extrainfo)
        identifier [184:49 - 184:60] systemerror
        argument_list [184:60 - 184:84] (p, extrainfo=extrainfo)
          ( [184:60 - 184:61] (
          identifier [184:61 - 184:62] p
          , [184:62 - 184:63] ,
          named_argument [184:64 - 184:83] extrainfo=extrainfo
            identifier [184:64 - 184:73] extrainfo
            operator [184:73 - 184:74] =
            identifier [184:74 - 184:83] extrainfo
          ) [184:83 - 184:84] )
      : [184:85 - 184:86] :
      identifier [184:87 - 184:94] nothing
  assignment [185:0 - 185:119] systemerror(p, errno::Cint=Libc.errno(); extrainfo=nothing) ...
    call_expression [185:0 - 185:59] systemerror(p, errno::Cint=Libc.errno(); extrainfo=nothing)
      identifier [185:0 - 185:11] systemerror
      argument_list [185:11 - 185:59] (p, errno::Cint=Libc.errno(); extrainfo=nothing)
        ( [185:11 - 185:12] (
        identifier [185:12 - 185:13] p
        , [185:13 - 185:14] ,
        named_argument [185:15 - 185:39] errno::Cint=Libc.errno()
          typed_expression [185:15 - 185:26] errno::Cint
            identifier [185:15 - 185:20] errno
            :: [185:20 - 185:22] ::
            identifier [185:22 - 185:26] Cint
          operator [185:26 - 185:27] =
          call_expression [185:27 - 185:39] Libc.errno()
            field_expression [185:27 - 185:37] Libc.errno
              identifier [185:27 - 185:31] Libc
              . [185:31 - 185:32] .
              identifier [185:32 - 185:37] errno
            argument_list [185:37 - 185:39] ()
              ( [185:37 - 185:38] (
              ) [185:38 - 185:39] )
        ; [185:39 - 185:40] ;
        named_argument [185:41 - 185:58] extrainfo=nothing
          identifier [185:41 - 185:50] extrainfo
          operator [185:50 - 185:51] =
          identifier [185:51 - 185:58] nothing
        ) [185:58 - 185:59] )
    operator [185:60 - 185:61] =
    call_expression [185:62 - 185:119] throw(Main.Base.SystemError(string(p), errno, extrainfo))
      identifier [185:62 - 185:67] throw
      argument_list [185:67 - 185:119] (Main.Base.SystemError(string(p), errno, extrainfo))
        ( [185:67 - 185:68] (
        call_expression [185:68 - 185:118] Main.Base.SystemError(string(p), errno, extrainfo)
          field_expression [185:68 - 185:89] Main.Base.SystemError
            field_expression [185:68 - 185:77] Main.Base
              identifier [185:68 - 185:72] Main
              . [185:72 - 185:73] .
              identifier [185:73 - 185:77] Base
            . [185:77 - 185:78] .
            identifier [185:78 - 185:89] SystemError
          argument_list [185:89 - 185:118] (string(p), errno, extrainfo)
            ( [185:89 - 185:90] (
            call_expression [185:90 - 185:99] string(p)
              identifier [185:90 - 185:96] string
              argument_list [185:96 - 185:99] (p)
                ( [185:96 - 185:97] (
                identifier [185:97 - 185:98] p
                ) [185:98 - 185:99] )
            , [185:99 - 185:100] ,
            identifier [185:101 - 185:106] errno
            , [185:106 - 185:107] ,
            identifier [185:108 - 185:117] extrainfo
            ) [185:117 - 185:118] )
        ) [185:118 - 185:119] )
  line_comment [187:0 - 187:43] ## system errors from Windows API functions
  struct_definition [188:0 - 191:3] struct WindowsErrorInfo
    errnum::UInt32
    extrainfo
end
    struct [188:0 - 188:6] struct
    type_head [188:7 - 188:23] WindowsErrorInfo
      identifier [188:7 - 188:23] WindowsErrorInfo
    typed_expression [189:4 - 189:18] errnum::UInt32
      identifier [189:4 - 189:10] errnum
      :: [189:10 - 189:12] ::
      identifier [189:12 - 189:18] UInt32
    identifier [190:4 - 190:13] extrainfo
    end [191:0 - 191:3] end
  string_literal [192:0 - 198:3] """
    windowserror(sysfunc[, code::UInt32=Libc.GetLastErro...
    """ [192:0 - 192:3] """
    content [192:3 - 198:0] 
    windowserror(sysfunc[, code::UInt32=Libc.GetLastError()...
  assignment [199:0 - 199:96] windowserror(p, b::Bool; extrainfo=nothing) = b ? windowserr...
    call_expression [199:0 - 199:43] windowserror(p, b::Bool; extrainfo=nothing)
      identifier [199:0 - 199:12] windowserror
      argument_list [199:12 - 199:43] (p, b::Bool; extrainfo=nothing)
        ( [199:12 - 199:13] (
        identifier [199:13 - 199:14] p
        , [199:14 - 199:15] ,
        typed_expression [199:16 - 199:23] b::Bool
          identifier [199:16 - 199:17] b
          :: [199:17 - 199:19] ::
          identifier [199:19 - 199:23] Bool
        ; [199:23 - 199:24] ;
        named_argument [199:25 - 199:42] extrainfo=nothing
          identifier [199:25 - 199:34] extrainfo
          operator [199:34 - 199:35] =
          identifier [199:35 - 199:42] nothing
        ) [199:42 - 199:43] )
    operator [199:44 - 199:45] =
    ternary_expression [199:46 - 199:96] b ? windowserror(p, extrainfo=extrainfo) : nothing
      identifier [199:46 - 199:47] b
      ? [199:48 - 199:49] ?
      call_expression [199:50 - 199:86] windowserror(p, extrainfo=extrainfo)
        identifier [199:50 - 199:62] windowserror
        argument_list [199:62 - 199:86] (p, extrainfo=extrainfo)
          ( [199:62 - 199:63] (
          identifier [199:63 - 199:64] p
          , [199:64 - 199:65] ,
          named_argument [199:66 - 199:85] extrainfo=extrainfo
            identifier [199:66 - 199:75] extrainfo
            operator [199:75 - 199:76] =
            identifier [199:76 - 199:85] extrainfo
          ) [199:85 - 199:86] )
      : [199:87 - 199:88] :
      identifier [199:89 - 199:96] nothing
  assignment [200:0 - 200:148] windowserror(p, code::UInt32=Libc.GetLastError(); extrainfo=...
    call_expression [200:0 - 200:68] windowserror(p, code::UInt32=Libc.GetLastError(); extrainfo=...
      identifier [200:0 - 200:12] windowserror
      argument_list [200:12 - 200:68] (p, code::UInt32=Libc.GetLastError(); extrainfo=nothing)
        ( [200:12 - 200:13] (
        identifier [200:13 - 200:14] p
        , [200:14 - 200:15] ,
        named_argument [200:16 - 200:48] code::UInt32=Libc.GetLastError()
          typed_expression [200:16 - 200:28] code::UInt32
            identifier [200:16 - 200:20] code
            :: [200:20 - 200:22] ::
            identifier [200:22 - 200:28] UInt32
          operator [200:28 - 200:29] =
          call_expression [200:29 - 200:48] Libc.GetLastError()
            field_expression [200:29 - 200:46] Libc.GetLastError
              identifier [200:29 - 200:33] Libc
              . [200:33 - 200:34] .
              identifier [200:34 - 200:46] GetLastError
            argument_list [200:46 - 200:48] ()
              ( [200:46 - 200:47] (
              ) [200:47 - 200:48] )
        ; [200:48 - 200:49] ;
        named_argument [200:50 - 200:67] extrainfo=nothing
          identifier [200:50 - 200:59] extrainfo
          operator [200:59 - 200:60] =
          identifier [200:60 - 200:67] nothing
        ) [200:67 - 200:68] )
    operator [200:69 - 200:70] =
    call_expression [200:71 - 200:148] throw(Main.Base.SystemError(string(p), 0, WindowsErrorInfo(c...
      identifier [200:71 - 200:76] throw
      argument_list [200:76 - 200:148] (Main.Base.SystemError(string(p), 0, WindowsErrorInfo(code, ...
        ( [200:76 - 200:77] (
        call_expression [200:77 - 200:147] Main.Base.SystemError(string(p), 0, WindowsErrorInfo(code, e...
          field_expression [200:77 - 200:98] Main.Base.SystemError
            field_expression [200:77 - 200:86] Main.Base
              identifier [200:77 - 200:81] Main
              . [200:81 - 200:82] .
              identifier [200:82 - 200:86] Base
            . [200:86 - 200:87] .
            identifier [200:87 - 200:98] SystemError
          argument_list [200:98 - 200:147] (string(p), 0, WindowsErrorInfo(code, extrainfo))
            ( [200:98 - 200:99] (
            call_expression [200:99 - 200:108] string(p)
              identifier [200:99 - 200:105] string
              argument_list [200:105 - 200:108] (p)
                ( [200:105 - 200:106] (
                identifier [200:106 - 200:107] p
                ) [200:107 - 200:108] )
            , [200:108 - 200:109] ,
            integer_literal [200:110 - 200:111] 0
            , [200:111 - 200:112] ,
            call_expression [200:113 - 200:146] WindowsErrorInfo(code, extrainfo)
              identifier [200:113 - 200:129] WindowsErrorInfo
              argument_list [200:129 - 200:146] (code, extrainfo)
                ( [200:129 - 200:130] (
                identifier [200:130 - 200:134] code
                , [200:134 - 200:135] ,
                identifier [200:136 - 200:145] extrainfo
                ) [200:145 - 200:146] )
            ) [200:146 - 200:147] )
        ) [200:147 - 200:148] )
  line_comment [203:0 - 203:21] ## assertion macro ##
  string_literal [206:0 - 228:3] """
    @assert cond [text]

Throw an [`AssertionError`](@re...
    """ [206:0 - 206:3] """
    content [206:3 - 228:0] 
    @assert cond [text]

Throw an [`AssertionError`](@ref) ...
  macro_definition [229:0 - 243:3] macro assert(ex, msgs...)
    msg = isempty(msgs) ? ex : msg...
    macro [229:0 - 229:5] macro
    signature [229:6 - 229:25] assert(ex, msgs...)
      call_expression [229:6 - 229:25] assert(ex, msgs...)
        identifier [229:6 - 229:12] assert
        argument_list [229:12 - 229:25] (ex, msgs...)
          ( [229:12 - 229:13] (
          identifier [229:13 - 229:15] ex
          , [229:15 - 229:16] ,
          splat_expression [229:17 - 229:24] msgs...
            identifier [229:17 - 229:21] msgs
            ... [229:21 - 229:24] ...
          ) [229:24 - 229:25] )
    assignment [230:4 - 230:38] msg = isempty(msgs) ? ex : msgs[1]
      identifier [230:4 - 230:7] msg
      operator [230:8 - 230:9] =
      ternary_expression [230:10 - 230:38] isempty(msgs) ? ex : msgs[1]
        call_expression [230:10 - 230:23] isempty(msgs)
          identifier [230:10 - 230:17] isempty
          argument_list [230:17 - 230:23] (msgs)
            ( [230:17 - 230:18] (
            identifier [230:18 - 230:22] msgs
            ) [230:22 - 230:23] )
        ? [230:24 - 230:25] ?
        identifier [230:26 - 230:28] ex
        : [230:29 - 230:30] :
        index_expression [230:31 - 230:38] msgs[1]
          identifier [230:31 - 230:35] msgs
          vector_expression [230:35 - 230:38] [1]
            [ [230:35 - 230:36] [
            integer_literal [230:36 - 230:37] 1
            ] [230:37 - 230:38] ]
    if_statement [231:4 - 241:7] if isa(msg, AbstractString)
        msg = msg # pass-through...
      if [231:4 - 231:6] if
      call_expression [231:7 - 231:31] isa(msg, AbstractString)
        identifier [231:7 - 231:10] isa
        argument_list [231:10 - 231:31] (msg, AbstractString)
          ( [231:10 - 231:11] (
          identifier [231:11 - 231:14] msg
          , [231:14 - 231:15] ,
          identifier [231:16 - 231:30] AbstractString
          ) [231:30 - 231:31] )
      assignment [232:8 - 232:17] msg = msg
        identifier [232:8 - 232:11] msg
        operator [232:12 - 232:13] =
        identifier [232:14 - 232:17] msg
      line_comment [232:18 - 232:32] # pass-through
      elseif_clause [233:4 - 236:0] elseif !isempty(msgs) && (isa(msg, Expr) || isa(msg, Symbol)...
        elseif [233:4 - 233:10] elseif
        binary_expression [233:11 - 233:65] !isempty(msgs) && (isa(msg, Expr) || isa(msg, Symbol))
          unary_expression [233:11 - 233:25] !isempty(msgs)
            operator [233:11 - 233:12] !
            call_expression [233:12 - 233:25] isempty(msgs)
              identifier [233:12 - 233:19] isempty
              argument_list [233:19 - 233:25] (msgs)
                ( [233:19 - 233:20] (
                identifier [233:20 - 233:24] msgs
                ) [233:24 - 233:25] )
          operator [233:26 - 233:28] &&
          parenthesized_expression [233:29 - 233:65] (isa(msg, Expr) || isa(msg, Symbol))
            ( [233:29 - 233:30] (
            binary_expression [233:30 - 233:64] isa(msg, Expr) || isa(msg, Symbol)
              call_expression [233:30 - 233:44] isa(msg, Expr)
                identifier [233:30 - 233:33] isa
                argument_list [233:33 - 233:44] (msg, Expr)
                  ( [233:33 - 233:34] (
                  identifier [233:34 - 233:37] msg
                  , [233:37 - 233:38] ,
                  identifier [233:39 - 233:43] Expr
                  ) [233:43 - 233:44] )
              operator [233:45 - 233:47] ||
              call_expression [233:48 - 233:64] isa(msg, Symbol)
                identifier [233:48 - 233:51] isa
                argument_list [233:51 - 233:64] (msg, Symbol)
                  ( [233:51 - 233:52] (
                  identifier [233:52 - 233:55] msg
                  , [233:55 - 233:56] ,
                  identifier [233:57 - 233:63] Symbol
                  ) [233:63 - 233:64] )
            ) [233:64 - 233:65] )
        line_comment [234:8 - 234:53] # message is an expression needing evaluating
        assignment [235:8 - 235:47] msg = :($_assert_tostring($(esc(msg))))
          identifier [235:8 - 235:11] msg
          operator [235:12 - 235:13] =
          quote_expression [235:14 - 235:47] :($_assert_tostring($(esc(msg))))
            : [235:14 - 235:15] :
            parenthesized_expression [235:15 - 235:47] ($_assert_tostring($(esc(msg))))
              ( [235:15 - 235:16] (
              call_expression [235:16 - 235:46] $_assert_tostring($(esc(msg)))
                interpolation_expression [235:16 - 235:33] $_assert_tostring
                  $ [235:16 - 235:17] $
                  identifier [235:17 - 235:33] _assert_tostring
                argument_list [235:33 - 235:46] ($(esc(msg)))
                  ( [235:33 - 235:34] (
                  interpolation_expression [235:34 - 235:45] $(esc(msg))
                    $ [235:34 - 235:35] $
                    parenthesized_expression [235:35 - 235:45] (esc(msg))
                      ( [235:35 - 235:36] (
                      call_expression [235:36 - 235:44] esc(msg)
                        identifier [235:36 - 235:39] esc
                        argument_list [235:39 - 235:44] (msg)
                          ( [235:39 - 235:40] (
                          identifier [235:40 - 235:43] msg
                          ) [235:43 - 235:44] )
                      ) [235:44 - 235:45] )
                  ) [235:45 - 235:46] )
              ) [235:46 - 235:47] )
      elseif_clause [236:4 - 238:0] elseif isdefined(Main, :Base) && isdefined(Main.Base, :strin...
        elseif [236:4 - 236:10] elseif
        binary_expression [236:11 - 236:103] isdefined(Main, :Base) && isdefined(Main.Base, :string) && a...
          binary_expression [236:11 - 236:66] isdefined(Main, :Base) && isdefined(Main.Base, :string)
            call_expression [236:11 - 236:33] isdefined(Main, :Base)
              identifier [236:11 - 236:20] isdefined
              argument_list [236:20 - 236:33] (Main, :Base)
                ( [236:20 - 236:21] (
                identifier [236:21 - 236:25] Main
                , [236:25 - 236:26] ,
                quote_expression [236:27 - 236:32] :Base
                  : [236:27 - 236:28] :
                  identifier [236:28 - 236:32] Base
                ) [236:32 - 236:33] )
            operator [236:34 - 236:36] &&
            call_expression [236:37 - 236:66] isdefined(Main.Base, :string)
              identifier [236:37 - 236:46] isdefined
              argument_list [236:46 - 236:66] (Main.Base, :string)
                ( [236:46 - 236:47] (
                field_expression [236:47 - 236:56] Main.Base
                  identifier [236:47 - 236:51] Main
                  . [236:51 - 236:52] .
                  identifier [236:52 - 236:56] Base
                , [236:56 - 236:57] ,
                quote_expression [236:58 - 236:65] :string
                  : [236:58 - 236:59] :
                  identifier [236:59 - 236:65] string
                ) [236:65 - 236:66] )
          operator [236:67 - 236:69] &&
          call_expression [236:70 - 236:103] applicable(Main.Base.string, msg)
            identifier [236:70 - 236:80] applicable
            argument_list [236:80 - 236:103] (Main.Base.string, msg)
              ( [236:80 - 236:81] (
              field_expression [236:81 - 236:97] Main.Base.string
                field_expression [236:81 - 236:90] Main.Base
                  identifier [236:81 - 236:85] Main
                  . [236:85 - 236:86] .
                  identifier [236:86 - 236:90] Base
                . [236:90 - 236:91] .
                identifier [236:91 - 236:97] string
              , [236:97 - 236:98] ,
              identifier [236:99 - 236:102] msg
              ) [236:102 - 236:103] )
        assignment [237:8 - 237:35] msg = Main.Base.string(msg)
          identifier [237:8 - 237:11] msg
          operator [237:12 - 237:13] =
          call_expression [237:14 - 237:35] Main.Base.string(msg)
            field_expression [237:14 - 237:30] Main.Base.string
              field_expression [237:14 - 237:23] Main.Base
                identifier [237:14 - 237:18] Main
                . [237:18 - 237:19] .
                identifier [237:19 - 237:23] Base
              . [237:23 - 237:24] .
              identifier [237:24 - 237:30] string
            argument_list [237:30 - 237:35] (msg)
              ( [237:30 - 237:31] (
              identifier [237:31 - 237:34] msg
              ) [237:34 - 237:35] )
      else_clause [238:4 - 241:0] else
        # string() might not be defined during bootstra...
        else [238:4 - 238:8] else
        line_comment [239:8 - 239:56] # string() might not be defined during bootstrap
        assignment [240:8 - 240:55] msg = :($_assert_tostring($(Expr(:quote,msg))))
          identifier [240:8 - 240:11] msg
          operator [240:12 - 240:13] =
          quote_expression [240:14 - 240:55] :($_assert_tostring($(Expr(:quote,msg))))
            : [240:14 - 240:15] :
            parenthesized_expression [240:15 - 240:55] ($_assert_tostring($(Expr(:quote,msg))))
              ( [240:15 - 240:16] (
              call_expression [240:16 - 240:54] $_assert_tostring($(Expr(:quote,msg)))
                interpolation_expression [240:16 - 240:33] $_assert_tostring
                  $ [240:16 - 240:17] $
                  identifier [240:17 - 240:33] _assert_tostring
                argument_list [240:33 - 240:54] ($(Expr(:quote,msg)))
                  ( [240:33 - 240:34] (
                  interpolation_expression [240:34 - 240:53] $(Expr(:quote,msg))
                    $ [240:34 - 240:35] $
                    parenthesized_expression [240:35 - 240:53] (Expr(:quote,msg))
                      ( [240:35 - 240:36] (
                      call_expression [240:36 - 240:52] Expr(:quote,msg)
                        identifier [240:36 - 240:40] Expr
                        argument_list [240:40 - 240:52] (:quote,msg)
                          ( [240:40 - 240:41] (
                          quote_expression [240:41 - 240:47] :quote
                            : [240:41 - 240:42] :
                            identifier [240:42 - 240:47] quote
                          , [240:47 - 240:48] ,
                          identifier [240:48 - 240:51] msg
                          ) [240:51 - 240:52] )
                      ) [240:52 - 240:53] )
                  ) [240:53 - 240:54] )
              ) [240:54 - 240:55] )
      end [241:4 - 241:7] end
    return_statement [242:4 - 242:67] return :($(esc(ex)) ? $(nothing) : throw(AssertionError($msg...
      return [242:4 - 242:10] return
      quote_expression [242:11 - 242:67] :($(esc(ex)) ? $(nothing) : throw(AssertionError($msg)))
        : [242:11 - 242:12] :
        parenthesized_expression [242:12 - 242:67] ($(esc(ex)) ? $(nothing) : throw(AssertionError($msg)))
          ( [242:12 - 242:13] (
          ternary_expression [242:13 - 242:66] $(esc(ex)) ? $(nothing) : throw(AssertionError($msg))
            interpolation_expression [242:13 - 242:23] $(esc(ex))
              $ [242:13 - 242:14] $
              parenthesized_expression [242:14 - 242:23] (esc(ex))
                ( [242:14 - 242:15] (
                call_expression [242:15 - 242:22] esc(ex)
                  identifier [242:15 - 242:18] esc
                  argument_list [242:18 - 242:22] (ex)
                    ( [242:18 - 242:19] (
                    identifier [242:19 - 242:21] ex
                    ) [242:21 - 242:22] )
                ) [242:22 - 242:23] )
            ? [242:24 - 242:25] ?
            interpolation_expression [242:26 - 242:36] $(nothing)
              $ [242:26 - 242:27] $
              parenthesized_expression [242:27 - 242:36] (nothing)
                ( [242:27 - 242:28] (
                identifier [242:28 - 242:35] nothing
                ) [242:35 - 242:36] )
            : [242:37 - 242:38] :
            call_expression [242:39 - 242:66] throw(AssertionError($msg))
              identifier [242:39 - 242:44] throw
              argument_list [242:44 - 242:66] (AssertionError($msg))
                ( [242:44 - 242:45] (
                call_expression [242:45 - 242:65] AssertionError($msg)
                  identifier [242:45 - 242:59] AssertionError
                  argument_list [242:59 - 242:65] ($msg)
                    ( [242:59 - 242:60] (
                    interpolation_expression [242:60 - 242:64] $msg
                      $ [242:60 - 242:61] $
                      identifier [242:61 - 242:64] msg
                    ) [242:64 - 242:65] )
                ) [242:65 - 242:66] )
          ) [242:66 - 242:67] )
    end [243:0 - 243:3] end
  line_comment [245:0 - 245:72] # this may be overridden in contexts where `string(::Expr)` ...
  assignment [246:0 - 246:90] _assert_tostring(@nospecialize(msg)) = Core.compilerbarrier(...
    call_expression [246:0 - 246:36] _assert_tostring(@nospecialize(msg))
      identifier [246:0 - 246:16] _assert_tostring
      argument_list [246:16 - 246:36] (@nospecialize(msg))
        ( [246:16 - 246:17] (
        macrocall_expression [246:17 - 246:35] @nospecialize(msg)
          macro_identifier [246:17 - 246:30] @nospecialize
            @ [246:17 - 246:18] @
            identifier [246:18 - 246:30] nospecialize
          argument_list [246:30 - 246:35] (msg)
            ( [246:30 - 246:31] (
            identifier [246:31 - 246:34] msg
            ) [246:34 - 246:35] )
        ) [246:35 - 246:36] )
    operator [246:37 - 246:38] =
    call_expression [246:39 - 246:90] Core.compilerbarrier(:type, __assert_tostring)(msg)
      call_expression [246:39 - 246:85] Core.compilerbarrier(:type, __assert_tostring)
        field_expression [246:39 - 246:59] Core.compilerbarrier
          identifier [246:39 - 246:43] Core
          . [246:43 - 246:44] .
          identifier [246:44 - 246:59] compilerbarrier
        argument_list [246:59 - 246:85] (:type, __assert_tostring)
          ( [246:59 - 246:60] (
          quote_expression [246:60 - 246:65] :type
            : [246:60 - 246:61] :
            identifier [246:61 - 246:65] type
          , [246:65 - 246:66] ,
          identifier [246:67 - 246:84] __assert_tostring
          ) [246:84 - 246:85] )
      argument_list [246:85 - 246:90] (msg)
        ( [246:85 - 246:86] (
        identifier [246:86 - 246:89] msg
        ) [246:89 - 246:90] )
  assignment [247:0 - 248:62] __assert_tostring(msg) = isdefined(Main, :Base) ? Main.Base....
    call_expression [247:0 - 247:22] __assert_tostring(msg)
      identifier [247:0 - 247:17] __assert_tostring
      argument_list [247:17 - 247:22] (msg)
        ( [247:17 - 247:18] (
        identifier [247:18 - 247:21] msg
        ) [247:21 - 247:22] )
    operator [247:23 - 247:24] =
    ternary_expression [247:25 - 248:62] isdefined(Main, :Base) ? Main.Base.string(msg) :
    (Core.p...
      call_expression [247:25 - 247:47] isdefined(Main, :Base)
        identifier [247:25 - 247:34] isdefined
        argument_list [247:34 - 247:47] (Main, :Base)
          ( [247:34 - 247:35] (
          identifier [247:35 - 247:39] Main
          , [247:39 - 247:40] ,
          quote_expression [247:41 - 247:46] :Base
            : [247:41 - 247:42] :
            identifier [247:42 - 247:46] Base
          ) [247:46 - 247:47] )
      ? [247:48 - 247:49] ?
      call_expression [247:50 - 247:71] Main.Base.string(msg)
        field_expression [247:50 - 247:66] Main.Base.string
          field_expression [247:50 - 247:59] Main.Base
            identifier [247:50 - 247:54] Main
            . [247:54 - 247:55] .
            identifier [247:55 - 247:59] Base
          . [247:59 - 247:60] .
          identifier [247:60 - 247:66] string
        argument_list [247:66 - 247:71] (msg)
          ( [247:66 - 247:67] (
          identifier [247:67 - 247:70] msg
          ) [247:70 - 247:71] )
      : [247:72 - 247:73] :
      parenthesized_expression [248:4 - 248:62] (Core.println(msg); "Error during bootstrap. See stdout.")
        ( [248:4 - 248:5] (
        call_expression [248:5 - 248:22] Core.println(msg)
          field_expression [248:5 - 248:17] Core.println
            identifier [248:5 - 248:9] Core
            . [248:9 - 248:10] .
            identifier [248:10 - 248:17] println
          argument_list [248:17 - 248:22] (msg)
            ( [248:17 - 248:18] (
            identifier [248:18 - 248:21] msg
            ) [248:21 - 248:22] )
        ; [248:22 - 248:23] ;
        string_literal [248:24 - 248:61] "Error during bootstrap. See stdout."
          " [248:24 - 248:25] "
          content [248:25 - 248:60] Error during bootstrap. See stdout.
        ) [248:61 - 248:62] )
  struct_definition [250:0 - 261:3] struct ExponentialBackOff
    n::Int
    first_delay::Float6...
    struct [250:0 - 250:6] struct
    type_head [250:7 - 250:25] ExponentialBackOff
      identifier [250:7 - 250:25] ExponentialBackOff
    typed_expression [251:4 - 251:10] n::Int
      identifier [251:4 - 251:5] n
      :: [251:5 - 251:7] ::
      identifier [251:7 - 251:10] Int
    typed_expression [252:4 - 252:24] first_delay::Float64
      identifier [252:4 - 252:15] first_delay
      :: [252:15 - 252:17] ::
      identifier [252:17 - 252:24] Float64
    typed_expression [253:4 - 253:22] max_delay::Float64
      identifier [253:4 - 253:13] max_delay
      :: [253:13 - 253:15] ::
      identifier [253:15 - 253:22] Float64
    typed_expression [254:4 - 254:19] factor::Float64
      identifier [254:4 - 254:10] factor
      :: [254:10 - 254:12] ::
      identifier [254:12 - 254:19] Float64
    typed_expression [255:4 - 255:19] jitter::Float64
      identifier [255:4 - 255:10] jitter
      :: [255:10 - 255:12] ::
      identifier [255:12 - 255:19] Float64
    function_definition [257:4 - 260:7] function ExponentialBackOff(n, first_delay, max_delay, facto...
      function [257:4 - 257:12] function
      signature [257:13 - 257:74] ExponentialBackOff(n, first_delay, max_delay, factor, jitter...
        call_expression [257:13 - 257:74] ExponentialBackOff(n, first_delay, max_delay, factor, jitter...
          identifier [257:13 - 257:31] ExponentialBackOff
          argument_list [257:31 - 257:74] (n, first_delay, max_delay, factor, jitter)
            ( [257:31 - 257:32] (
            identifier [257:32 - 257:33] n
            , [257:33 - 257:34] ,
            identifier [257:35 - 257:46] first_delay
            , [257:46 - 257:47] ,
            identifier [257:48 - 257:57] max_delay
            , [257:57 - 257:58] ,
            identifier [257:59 - 257:65] factor
            , [257:65 - 257:66] ,
            identifier [257:67 - 257:73] jitter
            ) [257:73 - 257:74] )
      binary_expression [258:8 - 258:109] all(x->x>=0, (n, first_delay, max_delay, factor, jitter)) ||...
        call_expression [258:8 - 258:65] all(x->x>=0, (n, first_delay, max_delay, factor, jitter))
          identifier [258:8 - 258:11] all
          argument_list [258:11 - 258:65] (x->x>=0, (n, first_delay, max_delay, factor, jitter))
            ( [258:11 - 258:12] (
            arrow_function_expression [258:12 - 258:19] x->x>=0
              identifier [258:12 - 258:13] x
              -> [258:13 - 258:15] ->
              binary_expression [258:15 - 258:19] x>=0
                identifier [258:15 - 258:16] x
                operator [258:16 - 258:18] >=
                integer_literal [258:18 - 258:19] 0
            , [258:19 - 258:20] ,
            tuple_expression [258:21 - 258:64] (n, first_delay, max_delay, factor, jitter)
              ( [258:21 - 258:22] (
              identifier [258:22 - 258:23] n
              , [258:23 - 258:24] ,
              identifier [258:25 - 258:36] first_delay
              , [258:36 - 258:37] ,
              identifier [258:38 - 258:47] max_delay
              , [258:47 - 258:48] ,
              identifier [258:49 - 258:55] factor
              , [258:55 - 258:56] ,
              identifier [258:57 - 258:63] jitter
              ) [258:63 - 258:64] )
            ) [258:64 - 258:65] )
        operator [258:66 - 258:68] ||
        call_expression [258:69 - 258:109] error("all inputs must be non-negative")
          identifier [258:69 - 258:74] error
          argument_list [258:74 - 258:109] ("all inputs must be non-negative")
            ( [258:74 - 258:75] (
            string_literal [258:75 - 258:108] "all inputs must be non-negative"
              " [258:75 - 258:76] "
              content [258:76 - 258:107] all inputs must be non-negative
            ) [258:108 - 258:109] )
      call_expression [259:8 - 259:54] new(n, first_delay, max_delay, factor, jitter)
        identifier [259:8 - 259:11] new
        argument_list [259:11 - 259:54] (n, first_delay, max_delay, factor, jitter)
          ( [259:11 - 259:12] (
          identifier [259:12 - 259:13] n
          , [259:13 - 259:14] ,
          identifier [259:15 - 259:26] first_delay
          , [259:26 - 259:27] ,
          identifier [259:28 - 259:37] max_delay
          , [259:37 - 259:38] ,
          identifier [259:39 - 259:45] factor
          , [259:45 - 259:46] ,
          identifier [259:47 - 259:53] jitter
          ) [259:53 - 259:54] )
      end [260:4 - 260:7] end
    end [261:0 - 261:3] end
  string_literal [263:0 - 269:3] """
    ExponentialBackOff(; n=1, first_delay=0.05, max_dela...
    """ [263:0 - 263:3] """
    content [263:3 - 269:0] 
    ExponentialBackOff(; n=1, first_delay=0.05, max_delay=1...
  assignment [270:0 - 271:65] ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, ...
    call_expression [270:0 - 270:83] ExponentialBackOff(; n=1, first_delay=0.05, max_delay=10.0, ...
      identifier [270:0 - 270:18] ExponentialBackOff
      argument_list [270:18 - 270:83] (; n=1, first_delay=0.05, max_delay=10.0, factor=5.0, jitter...
        ( [270:18 - 270:19] (
        ; [270:19 - 270:20] ;
        named_argument [270:21 - 270:24] n=1
          identifier [270:21 - 270:22] n
          operator [270:22 - 270:23] =
          integer_literal [270:23 - 270:24] 1
        , [270:24 - 270:25] ,
        named_argument [270:26 - 270:42] first_delay=0.05
          identifier [270:26 - 270:37] first_delay
          operator [270:37 - 270:38] =
          float_literal [270:38 - 270:42] 0.05
        , [270:42 - 270:43] ,
        named_argument [270:44 - 270:58] max_delay=10.0
          identifier [270:44 - 270:53] max_delay
          operator [270:53 - 270:54] =
          float_literal [270:54 - 270:58] 10.0
        , [270:58 - 270:59] ,
        named_argument [270:60 - 270:70] factor=5.0
          identifier [270:60 - 270:66] factor
          operator [270:66 - 270:67] =
          float_literal [270:67 - 270:70] 5.0
        , [270:70 - 270:71] ,
        named_argument [270:72 - 270:82] jitter=0.1
          identifier [270:72 - 270:78] jitter
          operator [270:78 - 270:79] =
          float_literal [270:79 - 270:82] 0.1
        ) [270:82 - 270:83] )
    operator [270:84 - 270:85] =
    call_expression [271:4 - 271:65] ExponentialBackOff(n, first_delay, max_delay, factor, jitter...
      identifier [271:4 - 271:22] ExponentialBackOff
      argument_list [271:22 - 271:65] (n, first_delay, max_delay, factor, jitter)
        ( [271:22 - 271:23] (
        identifier [271:23 - 271:24] n
        , [271:24 - 271:25] ,
        identifier [271:26 - 271:37] first_delay
        , [271:37 - 271:38] ,
        identifier [271:39 - 271:48] max_delay
        , [271:48 - 271:49] ,
        identifier [271:50 - 271:56] factor
        , [271:56 - 271:57] ,
        identifier [271:58 - 271:64] jitter
        ) [271:64 - 271:65] )
  function_definition [272:0 - 278:3] function iterate(ebo::ExponentialBackOff, state= (ebo.n, min...
    function [272:0 - 272:8] function
    signature [272:9 - 272:94] iterate(ebo::ExponentialBackOff, state= (ebo.n, min(ebo.firs...
      call_expression [272:9 - 272:94] iterate(ebo::ExponentialBackOff, state= (ebo.n, min(ebo.firs...
        identifier [272:9 - 272:16] iterate
        argument_list [272:16 - 272:94] (ebo::ExponentialBackOff, state= (ebo.n, min(ebo.first_delay...
          ( [272:16 - 272:17] (
          typed_expression [272:17 - 272:40] ebo::ExponentialBackOff
            identifier [272:17 - 272:20] ebo
            :: [272:20 - 272:22] ::
            identifier [272:22 - 272:40] ExponentialBackOff
          , [272:40 - 272:41] ,
          named_argument [272:42 - 272:93] state= (ebo.n, min(ebo.first_delay, ebo.max_delay))
            identifier [272:42 - 272:47] state
            operator [272:47 - 272:48] =
            tuple_expression [272:49 - 272:93] (ebo.n, min(ebo.first_delay, ebo.max_delay))
              ( [272:49 - 272:50] (
              field_expression [272:50 - 272:55] ebo.n
                identifier [272:50 - 272:53] ebo
                . [272:53 - 272:54] .
                identifier [272:54 - 272:55] n
              , [272:55 - 272:56] ,
              call_expression [272:57 - 272:92] min(ebo.first_delay, ebo.max_delay)
                identifier [272:57 - 272:60] min
                argument_list [272:60 - 272:92] (ebo.first_delay, ebo.max_delay)
                  ( [272:60 - 272:61] (
                  field_expression [272:61 - 272:76] ebo.first_delay
                    identifier [272:61 - 272:64] ebo
                    . [272:64 - 272:65] .
                    identifier [272:65 - 272:76] first_delay
                  , [272:76 - 272:77] ,
                  field_expression [272:78 - 272:91] ebo.max_delay
                    identifier [272:78 - 272:81] ebo
                    . [272:81 - 272:82] .
                    identifier [272:82 - 272:91] max_delay
                  ) [272:91 - 272:92] )
              ) [272:92 - 272:93] )
          ) [272:93 - 272:94] )
    binary_expression [273:4 - 273:34] state[1] < 1 && return nothing
      binary_expression [273:4 - 273:16] state[1] < 1
        index_expression [273:4 - 273:12] state[1]
          identifier [273:4 - 273:9] state
          vector_expression [273:9 - 273:12] [1]
            [ [273:9 - 273:10] [
            integer_literal [273:10 - 273:11] 1
            ] [273:11 - 273:12] ]
        operator [273:13 - 273:14] <
        integer_literal [273:15 - 273:16] 1
      operator [273:17 - 273:19] &&
      return_statement [273:20 - 273:34] return nothing
        return [273:20 - 273:26] return
        identifier [273:27 - 273:34] nothing
    assignment [274:4 - 274:23] next_n = state[1]-1
      identifier [274:4 - 274:10] next_n
      operator [274:11 - 274:12] =
      binary_expression [274:13 - 274:23] state[1]-1
        index_expression [274:13 - 274:21] state[1]
          identifier [274:13 - 274:18] state
          vector_expression [274:18 - 274:21] [1]
            [ [274:18 - 274:19] [
            integer_literal [274:19 - 274:20] 1
            ] [274:20 - 274:21] ]
        operator [274:21 - 274:22] -
        integer_literal [274:22 - 274:23] 1
    assignment [275:4 - 275:25] curr_delay = state[2]
      identifier [275:4 - 275:14] curr_delay
      operator [275:15 - 275:16] =
      index_expression [275:17 - 275:25] state[2]
        identifier [275:17 - 275:22] state
        vector_expression [275:22 - 275:25] [2]
          [ [275:22 - 275:23] [
          integer_literal [275:23 - 275:24] 2
          ] [275:24 - 275:25] ]
    assignment [276:4 - 276:121] next_delay = min(ebo.max_delay, state[2] * ebo.factor * (1.0...
      identifier [276:4 - 276:14] next_delay
      operator [276:15 - 276:16] =
      call_expression [276:17 - 276:121] min(ebo.max_delay, state[2] * ebo.factor * (1.0 - ebo.jitter...
        identifier [276:17 - 276:20] min
        argument_list [276:20 - 276:121] (ebo.max_delay, state[2] * ebo.factor * (1.0 - ebo.jitter + ...
          ( [276:20 - 276:21] (
          field_expression [276:21 - 276:34] ebo.max_delay
            identifier [276:21 - 276:24] ebo
            . [276:24 - 276:25] .
            identifier [276:25 - 276:34] max_delay
          , [276:34 - 276:35] ,
          binary_expression [276:36 - 276:120] state[2] * ebo.factor * (1.0 - ebo.jitter + (Libc.rand(Float...
            binary_expression [276:36 - 276:57] state[2] * ebo.factor
              index_expression [276:36 - 276:44] state[2]
                identifier [276:36 - 276:41] state
                vector_expression [276:41 - 276:44] [2]
                  [ [276:41 - 276:42] [
                  integer_literal [276:42 - 276:43] 2
                  ] [276:43 - 276:44] ]
              operator [276:45 - 276:46] *
              field_expression [276:47 - 276:57] ebo.factor
                identifier [276:47 - 276:50] ebo
                . [276:50 - 276:51] .
                identifier [276:51 - 276:57] factor
            operator [276:58 - 276:59] *
            parenthesized_expression [276:60 - 276:120] (1.0 - ebo.jitter + (Libc.rand(Float64) * 2.0 * ebo.jitter))
              ( [276:60 - 276:61] (
              binary_expression [276:61 - 276:119] 1.0 - ebo.jitter + (Libc.rand(Float64) * 2.0 * ebo.jitter)
                binary_expression [276:61 - 276:77] 1.0 - ebo.jitter
                  float_literal [276:61 - 276:64] 1.0
                  operator [276:65 - 276:66] -
                  field_expression [276:67 - 276:77] ebo.jitter
                    identifier [276:67 - 276:70] ebo
                    . [276:70 - 276:71] .
                    identifier [276:71 - 276:77] jitter
                operator [276:78 - 276:79] +
                parenthesized_expression [276:80 - 276:119] (Libc.rand(Float64) * 2.0 * ebo.jitter)
                  ( [276:80 - 276:81] (
                  binary_expression [276:81 - 276:118] Libc.rand(Float64) * 2.0 * ebo.jitter
                    binary_expression [276:81 - 276:105] Libc.rand(Float64) * 2.0
                      call_expression [276:81 - 276:99] Libc.rand(Float64)
                        field_expression [276:81 - 276:90] Libc.rand
                          identifier [276:81 - 276:85] Libc
                          . [276:85 - 276:86] .
                          identifier [276:86 - 276:90] rand
                        argument_list [276:90 - 276:99] (Float64)
                          ( [276:90 - 276:91] (
                          identifier [276:91 - 276:98] Float64
                          ) [276:98 - 276:99] )
                      operator [276:100 - 276:101] *
                      float_literal [276:102 - 276:105] 2.0
                    operator [276:106 - 276:107] *
                    field_expression [276:108 - 276:118] ebo.jitter
                      identifier [276:108 - 276:111] ebo
                      . [276:111 - 276:112] .
                      identifier [276:112 - 276:118] jitter
                  ) [276:118 - 276:119] )
              ) [276:119 - 276:120] )
          ) [276:120 - 276:121] )
    tuple_expression [277:4 - 277:38] (curr_delay, (next_n, next_delay))
      ( [277:4 - 277:5] (
      identifier [277:5 - 277:15] curr_delay
      , [277:15 - 277:16] ,
      tuple_expression [277:17 - 277:37] (next_n, next_delay)
        ( [277:17 - 277:18] (
        identifier [277:18 - 277:24] next_n
        , [277:24 - 277:25] ,
        identifier [277:26 - 277:36] next_delay
        ) [277:36 - 277:37] )
      ) [277:37 - 277:38] )
    end [278:0 - 278:3] end
  assignment [279:0 - 279:39] length(ebo::ExponentialBackOff) = ebo.n
    call_expression [279:0 - 279:31] length(ebo::ExponentialBackOff)
      identifier [279:0 - 279:6] length
      argument_list [279:6 - 279:31] (ebo::ExponentialBackOff)
        ( [279:6 - 279:7] (
        typed_expression [279:7 - 279:30] ebo::ExponentialBackOff
          identifier [279:7 - 279:10] ebo
          :: [279:10 - 279:12] ::
          identifier [279:12 - 279:30] ExponentialBackOff
        ) [279:30 - 279:31] )
    operator [279:32 - 279:33] =
    field_expression [279:34 - 279:39] ebo.n
      identifier [279:34 - 279:37] ebo
      . [279:37 - 279:38] .
      identifier [279:38 - 279:39] n
  assignment [280:0 - 280:44] eltype(::Type{ExponentialBackOff}) = Float64
    call_expression [280:0 - 280:34] eltype(::Type{ExponentialBackOff})
      identifier [280:0 - 280:6] eltype
      argument_list [280:6 - 280:34] (::Type{ExponentialBackOff})
        ( [280:6 - 280:7] (
        unary_typed_expression [280:7 - 280:33] ::Type{ExponentialBackOff}
          :: [280:7 - 280:9] ::
          parametrized_type_expression [280:9 - 280:33] Type{ExponentialBackOff}
            identifier [280:9 - 280:13] Type
            curly_expression [280:13 - 280:33] {ExponentialBackOff}
              { [280:13 - 280:14] {
              identifier [280:14 - 280:32] ExponentialBackOff
              } [280:32 - 280:33] }
        ) [280:33 - 280:34] )
    operator [280:35 - 280:36] =
    identifier [280:37 - 280:44] Float64
  string_literal [282:0 - 301:3] """
    retry(f;  delays=ExponentialBackOff(), check=nothing...
    """ [282:0 - 282:3] """
    content [282:3 - 301:0] 
    retry(f;  delays=ExponentialBackOff(), check=nothing) -...
  function_definition [302:0 - 322:3] function retry(f;  delays=ExponentialBackOff(), check=nothin...
    function [302:0 - 302:8] function
    signature [302:9 - 302:62] retry(f;  delays=ExponentialBackOff(), check=nothing)
      call_expression [302:9 - 302:62] retry(f;  delays=ExponentialBackOff(), check=nothing)
        identifier [302:9 - 302:14] retry
        argument_list [302:14 - 302:62] (f;  delays=ExponentialBackOff(), check=nothing)
          ( [302:14 - 302:15] (
          identifier [302:15 - 302:16] f
          ; [302:16 - 302:17] ;
          named_argument [302:19 - 302:46] delays=ExponentialBackOff()
            identifier [302:19 - 302:25] delays
            operator [302:25 - 302:26] =
            call_expression [302:26 - 302:46] ExponentialBackOff()
              identifier [302:26 - 302:44] ExponentialBackOff
              argument_list [302:44 - 302:46] ()
                ( [302:44 - 302:45] (
                ) [302:45 - 302:46] )
          , [302:46 - 302:47] ,
          named_argument [302:48 - 302:61] check=nothing
            identifier [302:48 - 302:53] check
            operator [302:53 - 302:54] =
            identifier [302:54 - 302:61] nothing
          ) [302:61 - 302:62] )
    arrow_function_expression [303:4 - 321:7] (args...; kwargs...) -> begin
        y = iterate(delays)
  ...
      argument_list [303:4 - 303:24] (args...; kwargs...)
        ( [303:4 - 303:5] (
        splat_expression [303:5 - 303:12] args...
          identifier [303:5 - 303:9] args
          ... [303:9 - 303:12] ...
        ; [303:12 - 303:13] ;
        splat_expression [303:14 - 303:23] kwargs...
          identifier [303:14 - 303:20] kwargs
          ... [303:20 - 303:23] ...
        ) [303:23 - 303:24] )
      -> [303:25 - 303:27] ->
      compound_statement [303:28 - 321:7] begin
        y = iterate(delays)
        while y !== nothin...
        begin [303:28 - 303:33] begin
        assignment [304:8 - 304:27] y = iterate(delays)
          identifier [304:8 - 304:9] y
          operator [304:10 - 304:11] =
          call_expression [304:12 - 304:27] iterate(delays)
            identifier [304:12 - 304:19] iterate
            argument_list [304:19 - 304:27] (delays)
              ( [304:19 - 304:20] (
              identifier [304:20 - 304:26] delays
              ) [304:26 - 304:27] )
        while_statement [305:8 - 318:11] while y !== nothing
            (delay, state) = y
         ...
          while [305:8 - 305:13] while
          binary_expression [305:14 - 305:27] y !== nothing
            identifier [305:14 - 305:15] y
            operator [305:16 - 305:19] !==
            identifier [305:20 - 305:27] nothing
          assignment [306:12 - 306:30] (delay, state) = y
            tuple_expression [306:12 - 306:26] (delay, state)
              ( [306:12 - 306:13] (
              identifier [306:13 - 306:18] delay
              , [306:18 - 306:19] ,
              identifier [306:20 - 306:25] state
              ) [306:25 - 306:26] )
            operator [306:27 - 306:28] =
            identifier [306:29 - 306:30] y
          try_statement [307:12 - 315:15] try
                return f(args...; kwargs...)
           ...
            try [307:12 - 307:15] try
            return_statement [308:16 - 308:44] return f(args...; kwargs...)
              return [308:16 - 308:22] return
              call_expression [308:23 - 308:44] f(args...; kwargs...)
                identifier [308:23 - 308:24] f
                argument_list [308:24 - 308:44] (args...; kwargs...)
                  ( [308:24 - 308:25] (
                  splat_expression [308:25 - 308:32] args...
                    identifier [308:25 - 308:29] args
                    ... [308:29 - 308:32] ...
                  ; [308:32 - 308:33] ;
                  splat_expression [308:34 - 308:43] kwargs...
                    identifier [308:34 - 308:40] kwargs
                    ... [308:40 - 308:43] ...
                  ) [308:43 - 308:44] )
            catch_clause [309:12 - 315:0] catch e
                if check !== nothing
               ...
              catch [309:12 - 309:17] catch
              identifier [309:18 - 309:19] e
              if_statement [310:16 - 314:19] if check !== nothing
                    result = check(stat...
                if [310:16 - 310:18] if
                binary_expression [310:19 - 310:36] check !== nothing
                  identifier [310:19 - 310:24] check
                  operator [310:25 - 310:28] !==
                  identifier [310:29 - 310:36] nothing
                assignment [311:20 - 311:44] result = check(state, e)
                  identifier [311:20 - 311:26] result
                  operator [311:27 - 311:28] =
                  call_expression [311:29 - 311:44] check(state, e)
                    identifier [311:29 - 311:34] check
                    argument_list [311:34 - 311:44] (state, e)
                      ( [311:34 - 311:35] (
                      identifier [311:35 - 311:40] state
                      , [311:40 - 311:41] ,
                      identifier [311:42 - 311:43] e
                      ) [311:43 - 311:44] )
                assignment [312:20 - 312:88] state, retry_or_not = length(result) == 2 ? result : (state,...
                  open_tuple [312:20 - 312:39] state, retry_or_not
                    identifier [312:20 - 312:25] state
                    , [312:25 - 312:26] ,
                    identifier [312:27 - 312:39] retry_or_not
                  operator [312:40 - 312:41] =
                  ternary_expression [312:42 - 312:88] length(result) == 2 ? result : (state, result)
                    binary_expression [312:42 - 312:61] length(result) == 2
                      call_expression [312:42 - 312:56] length(result)
                        identifier [312:42 - 312:48] length
                        argument_list [312:48 - 312:56] (result)
                          ( [312:48 - 312:49] (
                          identifier [312:49 - 312:55] result
                          ) [312:55 - 312:56] )
                      operator [312:57 - 312:59] ==
                      integer_literal [312:60 - 312:61] 2
                    ? [312:62 - 312:63] ?
                    identifier [312:64 - 312:70] result
                    : [312:71 - 312:72] :
                    tuple_expression [312:73 - 312:88] (state, result)
                      ( [312:73 - 312:74] (
                      identifier [312:74 - 312:79] state
                      , [312:79 - 312:80] ,
                      identifier [312:81 - 312:87] result
                      ) [312:87 - 312:88] )
                binary_expression [313:20 - 313:45] retry_or_not || rethrow()
                  identifier [313:20 - 313:32] retry_or_not
                  operator [313:33 - 313:35] ||
                  call_expression [313:36 - 313:45] rethrow()
                    identifier [313:36 - 313:43] rethrow
                    argument_list [313:43 - 313:45] ()
                      ( [313:43 - 313:44] (
                      ) [313:44 - 313:45] )
                end [314:16 - 314:19] end
            end [315:12 - 315:15] end
          call_expression [316:12 - 316:24] sleep(delay)
            identifier [316:12 - 316:17] sleep
            argument_list [316:17 - 316:24] (delay)
              ( [316:17 - 316:18] (
              identifier [316:18 - 316:23] delay
              ) [316:23 - 316:24] )
          assignment [317:12 - 317:38] y = iterate(delays, state)
            identifier [317:12 - 317:13] y
            operator [317:14 - 317:15] =
            call_expression [317:16 - 317:38] iterate(delays, state)
              identifier [317:16 - 317:23] iterate
              argument_list [317:23 - 317:38] (delays, state)
                ( [317:23 - 317:24] (
                identifier [317:24 - 317:30] delays
                , [317:30 - 317:31] ,
                identifier [317:32 - 317:37] state
                ) [317:37 - 317:38] )
          end [318:8 - 318:11] end
        line_comment [319:8 - 319:69] # When delays is out, just run the function without try/catc...
        return_statement [320:8 - 320:36] return f(args...; kwargs...)
          return [320:8 - 320:14] return
          call_expression [320:15 - 320:36] f(args...; kwargs...)
            identifier [320:15 - 320:16] f
            argument_list [320:16 - 320:36] (args...; kwargs...)
              ( [320:16 - 320:17] (
              splat_expression [320:17 - 320:24] args...
                identifier [320:17 - 320:21] args
                ... [320:21 - 320:24] ...
              ; [320:24 - 320:25] ;
              splat_expression [320:26 - 320:35] kwargs...
                identifier [320:26 - 320:32] kwargs
                ... [320:32 - 320:35] ...
              ) [320:35 - 320:36] )
        end [321:4 - 321:7] end
    end [322:0 - 322:3] end